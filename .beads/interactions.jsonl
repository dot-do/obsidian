{"id":"obsidian-0h4","title":"GREEN: MCP - Server implementation","description":"\n# GREEN Phase: MCP Server\n\n```typescript\n// src/mcp/server.ts\nexport interface McpServerConfig {\n  client: ObsidianClient\n}\n\nexport function createMcpServer(config: McpServerConfig): ObsidianMcpServer {\n  return new ObsidianMcpServer(config)\n}\n\nexport class ObsidianMcpServer {\n  private initialized = false\n  \n  constructor(private config: McpServerConfig) {}\n  \n  async handleRequest(request: JsonRpcRequest): Promise\u003cJsonRpcResponse\u003e {\n    try {\n      switch (request.method) {\n        case 'initialize':\n          return this.handleInitialize(request)\n        case 'tools/list':\n          return this.handleToolsList(request)\n        case 'tools/call':\n          return this.handleToolsCall(request)\n        default:\n          return this.error(request.id, -32601, 'Method not found')\n      }\n    } catch (err) {\n      return this.error(request.id, -32603, err.message)\n    }\n  }\n  \n  private handleInitialize(request: JsonRpcRequest): JsonRpcResponse {\n    this.initialized = true\n    return {\n      jsonrpc: '2.0',\n      id: request.id,\n      result: {\n        protocolVersion: '2024-11-05',\n        serverInfo: { name: 'obsidian.do', version: '1.0.0' },\n        capabilities: {\n          tools: { listChanged: false }\n        }\n      }\n    }\n  }\n  \n  private handleToolsList(request: JsonRpcRequest): JsonRpcResponse {\n    return {\n      jsonrpc: '2.0',\n      id: request.id,\n      result: {\n        tools: obsidianTools\n      }\n    }\n  }\n  \n  private async handleToolsCall(request: JsonRpcRequest): Promise\u003cJsonRpcResponse\u003e {\n    const { name, arguments: args } = request.params\n    \n    const tool = obsidianTools.find(t =\u003e t.name === name)\n    if (!tool) {\n      return this.error(request.id, -32602, \\`Unknown tool: \\${name}\\`)\n    }\n    \n    // Validate input\n    const validation = validateInput(tool.inputSchema, args)\n    if (!validation.valid) {\n      return this.error(request.id, -32602, validation.error)\n    }\n    \n    // Execute handler\n    const handler = toolHandlers[name]\n    const result = await handler(this.config.client, args)\n    \n    return {\n      jsonrpc: '2.0',\n      id: request.id,\n      result: {\n        content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]\n      }\n    }\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:00.228458-06:00","updated_at":"2026-01-05T12:03:39.310045-06:00","closed_at":"2026-01-05T12:03:39.310045-06:00","close_reason":"Implementation complete, all tests pass"}
{"id":"obsidian-1iw","title":"Epic: Client Module - Unified ObsidianClient","description":"\n# Client Module\n\nUnified client interface that combines all vault operations into a single, easy-to-use API.\n\n## Components\n- ObsidianClient (main class)\n- Context generator (AI-optimized vault context)\n- Note abstraction (file + content + metadata + backlinks)\n\n## Key Features\n- Single entry point for all vault operations\n- AI-friendly context generation\n- Convenience methods for common operations\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-05T09:47:55.663337-06:00","updated_at":"2026-01-05T09:47:55.663337-06:00"}
{"id":"obsidian-1pg","title":"GREEN: Fix SearchResult type conflicts","description":"SearchResult defined differently in types.ts (offset/length tuples) and search/engine.ts (line-based objects). This causes type confusion. Consolidate to single definition.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-05T13:23:14.886919-06:00","updated_at":"2026-01-05T13:39:03.329163-06:00","closed_at":"2026-01-05T13:39:03.329163-06:00","close_reason":"Fixed - SearchResult type conflicts resolved with TextSearchResult and VaultSearchResult"}
{"id":"obsidian-1yb","title":"REFACTOR: Vault module - optimization and caching","description":"\n# REFACTOR Phase: Vault Module\n\n## Tasks\n- [ ] Optimize file discovery with indexing\n- [ ] Add LRU cache for cachedRead\n- [ ] Implement debounced event emission\n- [ ] Add file locking for concurrent access\n- [ ] Comprehensive JSDoc\n- [ ] Performance benchmarks\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Cache hit rate metrics\n- [ ] Event batching for bulk operations\n","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T09:41:50.334193-06:00","updated_at":"2026-01-05T14:01:12.301421-06:00","dependencies":[{"issue_id":"obsidian-1yb","depends_on_id":"obsidian-byw","type":"blocks","created_at":"2026-01-05T09:47:41.487099-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-1yb","depends_on_id":"obsidian-d2s","type":"blocks","created_at":"2026-01-05T09:47:46.709163-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-1yb","depends_on_id":"obsidian-e8e","type":"blocks","created_at":"2026-01-05T09:47:51.949965-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-1yb","depends_on_id":"obsidian-8s9","type":"blocks","created_at":"2026-01-05T09:47:57.189044-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-20d","title":"GREEN: MetadataCache - Link resolver implementation","description":"\n# GREEN Phase: Link Resolver\n\n```typescript\n// src/metadata/link-resolver.ts\nexport class LinkResolver {\n  constructor(private vault: Vault) {}\n  \n  getFirstLinkpathDest(linkpath: string, sourcePath: string): TFile | null {\n    // Remove heading/block references\n    const basePath = linkpath.split('#')[0]\n    \n    // Try exact match first\n    const exact = this.vault.getFileByPath(basePath)\n    if (exact) return exact\n    \n    // Try with .md extension\n    const withExt = this.vault.getFileByPath(basePath + '.md')\n    if (withExt) return withExt\n    \n    // Search by basename\n    const sourceDir = path.dirname(sourcePath)\n    const candidates = this.vault.getMarkdownFiles()\n      .filter(f =\u003e f.basename === basePath || f.basename === basePath.replace('.md', ''))\n    \n    if (candidates.length === 0) return null\n    if (candidates.length === 1) return candidates[0]\n    \n    // Prefer same folder\n    const sameFolder = candidates.find(f =\u003e path.dirname(f.path) === sourceDir)\n    return sameFolder ?? candidates[0]\n  }\n  \n  fileToLinktext(file: TFile, sourcePath?: string): string {\n    // Check if basename is unique\n    const sameName = this.vault.getMarkdownFiles()\n      .filter(f =\u003e f.basename === file.basename)\n    \n    if (sameName.length === 1) {\n      return file.basename\n    }\n    \n    // Need to include path for disambiguation\n    return file.path.replace('.md', '')\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:38.695739-06:00","updated_at":"2026-01-05T11:33:10.23475-06:00","closed_at":"2026-01-05T11:33:10.23475-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-20d","depends_on_id":"obsidian-ph0","type":"blocks","created_at":"2026-01-05T09:48:08.865564-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-2co","title":"RED: Vault - CRUD operation tests","description":"\n# RED Phase: Vault CRUD Tests\n\n```typescript\n// test/vault/vault.test.ts\ndescribe('Vault', () =\u003e {\n  let vault: Vault\n  let backend: MemoryBackend\n  \n  beforeEach(() =\u003e {\n    backend = new MemoryBackend()\n    vault = new Vault(backend)\n  })\n  \n  describe('read operations', () =\u003e {\n    it('should read file content', async () =\u003e {\n      backend.write('test.md', '# Test')\n      const file = vault.getFileByPath('test.md')\n      const content = await vault.read(file!)\n      expect(content).toBe('# Test')\n    })\n    \n    it('should use cache for cachedRead', async () =\u003e {})\n    it('should read binary files', async () =\u003e {})\n  })\n  \n  describe('write operations', () =\u003e {\n    it('should create new file', async () =\u003e {\n      const file = await vault.create('new.md', '# New')\n      expect(file.path).toBe('new.md')\n      expect(await vault.read(file)).toBe('# New')\n    })\n    \n    it('should modify existing file', async () =\u003e {})\n    it('should append to file', async () =\u003e {})\n    it('should process file atomically', async () =\u003e {})\n  })\n  \n  describe('delete operations', () =\u003e {\n    it('should delete file', async () =\u003e {})\n    it('should trash file', async () =\u003e {})\n  })\n  \n  describe('rename/copy operations', () =\u003e {\n    it('should rename file and update path', async () =\u003e {})\n    it('should copy file to new path', async () =\u003e {})\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:40:56.822231-06:00","updated_at":"2026-01-05T10:08:50.098049-06:00","closed_at":"2026-01-05T10:08:50.098049-06:00","close_reason":"RED phase tests written and verified failing"}
{"id":"obsidian-2h8","title":"RED: Path traversal vulnerability in FileSystemBackend","description":"Critical security issue: fs-backend.ts resolvePath() doesn't validate paths stay within vault root. Attack vector: '../../../etc/passwd' can read files outside vault. Fix: Validate resolved path starts with basePath.","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-05T12:55:08.588114-06:00","updated_at":"2026-01-05T13:06:04.711406-06:00","closed_at":"2026-01-05T13:06:04.711406-06:00","close_reason":"Fixed, all tests pass"}
{"id":"obsidian-39h","title":"GREEN: CLI - Serve command implementation","description":"\n# GREEN Phase: CLI Serve Command\n\n```typescript\n// src/cli/serve.ts\nimport { Hono } from 'hono'\nimport { serve } from '@hono/node-server'\n\nexport function createServer(client: ObsidianClient) {\n  const app = new Hono()\n  \n  app.get('/health', (c) =\u003e c.json({ status: 'ok' }))\n  \n  app.get('/api/search', async (c) =\u003e {\n    const query = c.req.query('q') || ''\n    const tags = c.req.query('tags')?.split(',')\n    const limit = parseInt(c.req.query('limit') || '20')\n    \n    const results = await client.search.search(query, {\n      filter: { tags },\n      limit\n    })\n    \n    return c.json({\n      results: results.map(r =\u003e ({\n        path: r.file.path,\n        score: r.score\n      }))\n    })\n  })\n  \n  app.get('/api/notes/:path{.+}', async (c) =\u003e {\n    const notePath = c.req.param('path')\n    \n    try {\n      const note = await client.getNote(notePath)\n      return c.json({\n        path: note.file.path,\n        content: note.content,\n        metadata: note.metadata\n      })\n    } catch {\n      return c.json({ error: 'Note not found' }, 404)\n    }\n  })\n  \n  app.post('/api/notes/:path{.+}', async (c) =\u003e {\n    const notePath = c.req.param('path')\n    const body = await c.req.json()\n    \n    await client.createNote(notePath, body.content, body.frontmatter)\n    return c.json({ created: true, path: notePath })\n  })\n  \n  app.get('/api/backlinks/:path{.+}', async (c) =\u003e {\n    const notePath = c.req.param('path')\n    const backlinks = client.graph.getBacklinks(notePath)\n    \n    return c.json({\n      backlinks: backlinks.map(b =\u003e ({\n        path: b.file.path,\n        linkCount: b.links.length\n      }))\n    })\n  })\n  \n  return app\n}\n\n// Add to CLI\ncli\n  .command('serve', 'Start HTTP server')\n  .option('--port \u003cport\u003e', 'Port number', { default: 3000 })\n  .action(async (options) =\u003e {\n    const client = await createClient(options)\n    const app = createServer(client)\n    \n    const server = serve({\n      fetch: app.fetch,\n      port: options.port\n    })\n    \n    console.log(\\`Server running on http://localhost:\\${options.port}\\`)\n  })\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:15.140086-06:00","updated_at":"2026-01-05T12:03:39.310668-06:00","closed_at":"2026-01-05T12:03:39.310668-06:00","close_reason":"Implementation complete, all tests pass"}
{"id":"obsidian-3it","title":"RED: Search - Simple search tests","description":"\n# RED Phase: Simple Search Tests\n\n```typescript\n// test/search/simple.test.ts\ndescribe('prepareSimpleSearch', () =\u003e {\n  it('should match all words in query', () =\u003e {\n    const search = prepareSimpleSearch('hello world')\n    \n    expect(search('hello world')).not.toBeNull()\n    expect(search('world hello')).not.toBeNull()\n    expect(search('hello there world')).not.toBeNull()\n  })\n  \n  it('should return null if any word is missing', () =\u003e {\n    const search = prepareSimpleSearch('hello world')\n    \n    expect(search('hello there')).toBeNull()\n    expect(search('world only')).toBeNull()\n  })\n  \n  it('should match word boundaries', () =\u003e {\n    const search = prepareSimpleSearch('test')\n    \n    expect(search('test')).not.toBeNull()\n    expect(search('testing')).not.toBeNull()  // Prefix match\n    expect(search('contest')).toBeNull()       // Not at word boundary\n  })\n  \n  it('should include all match positions', () =\u003e {\n    const search = prepareSimpleSearch('hello world')\n    const result = search('hello beautiful world')\n    \n    expect(result?.matches).toHaveLength(2)\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:49.184828-06:00","updated_at":"2026-01-05T10:33:34.487771-06:00","closed_at":"2026-01-05T10:33:34.487771-06:00","close_reason":"TDD tests written and verified failing"}
{"id":"obsidian-3mz","title":"RED: Client - ObsidianClient tests","description":"\n# RED Phase: ObsidianClient Tests\n\n```typescript\n// test/client/client.test.ts\ndescribe('ObsidianClient', () =\u003e {\n  let client: ObsidianClient\n  \n  beforeEach(async () =\u003e {\n    client = new ObsidianClient({\n      vaultPath: tempDir,\n      backend: 'filesystem'\n    })\n    await client.initialize()\n  })\n  \n  describe('initialization', () =\u003e {\n    it('should initialize vault and metadata cache', async () =\u003e {\n      expect(client.vault).toBeDefined()\n      expect(client.metadataCache).toBeDefined()\n      expect(client.graph).toBeDefined()\n      expect(client.search).toBeDefined()\n    })\n    \n    it('should support memory backend', async () =\u003e {\n      const memClient = new ObsidianClient({\n        backend: 'memory',\n        initialFiles: { 'test.md': '# Test' }\n      })\n      await memClient.initialize()\n      \n      const note = await memClient.getNote('test.md')\n      expect(note.content).toBe('# Test')\n    })\n  })\n  \n  describe('getNote', () =\u003e {\n    it('should return note with content and metadata', async () =\u003e {\n      await client.createNote('test.md', '# Test\\n[[link]] #tag')\n      \n      const note = await client.getNote('test.md')\n      \n      expect(note.file.path).toBe('test.md')\n      expect(note.content).toBe('# Test\\n[[link]] #tag')\n      expect(note.metadata.links).toHaveLength(1)\n      expect(note.metadata.tags).toHaveLength(1)\n    })\n    \n    it('should include backlinks', async () =\u003e {\n      await client.createNote('a.md', '# A')\n      await client.createNote('b.md', '# B\\nLink to [[a]]')\n      \n      const note = await client.getNote('a.md')\n      \n      expect(note.backlinks).toHaveLength(1)\n      expect(note.backlinks[0].file.path).toBe('b.md')\n    })\n    \n    it('should throw for non-existent note', async () =\u003e {\n      await expect(client.getNote('missing.md')).rejects.toThrow()\n    })\n  })\n  \n  describe('createNote', () =\u003e {\n    it('should create note with content', async () =\u003e {\n      const file = await client.createNote('new.md', '# New Note')\n      \n      expect(file.path).toBe('new.md')\n      expect(await client.vault.read(file)).toBe('# New Note')\n    })\n    \n    it('should create note with frontmatter', async () =\u003e {\n      const file = await client.createNote('new.md', '# New', {\n        tags: ['project'],\n        status: 'active'\n      })\n      \n      const content = await client.vault.read(file)\n      expect(content).toContain('tags:')\n      expect(content).toContain('status: active')\n    })\n    \n    it('should create parent folders if needed', async () =\u003e {\n      await client.createNote('deep/nested/note.md', '# Deep')\n      \n      const exists = client.vault.getFileByPath('deep/nested/note.md')\n      expect(exists).not.toBeNull()\n    })\n  })\n  \n  describe('updateNote', () =\u003e {\n    it('should update note content', async () =\u003e {})\n  })\n  \n  describe('updateFrontmatter', () =\u003e {\n    it('should update frontmatter properties', async () =\u003e {\n      await client.createNote('test.md', '---\\nstatus: draft\\n---\\n# Test')\n      \n      await client.updateFrontmatter('test.md', { status: 'published' })\n      \n      const note = await client.getNote('test.md')\n      expect(note.metadata.frontmatter?.status).toBe('published')\n    })\n    \n    it('should add frontmatter if none exists', async () =\u003e {\n      await client.createNote('test.md', '# Test')\n      \n      await client.updateFrontmatter('test.md', { status: 'draft' })\n      \n      const content = await client.vault.read(client.vault.getFileByPath('test.md')!)\n      expect(content).toMatch(/^---/)\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:48:22.159733-06:00","updated_at":"2026-01-05T10:35:10.119504-06:00","closed_at":"2026-01-05T10:35:10.119504-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-407","title":"RED: Vault - Event system tests","description":"\n# RED Phase: Vault Events Tests\n\n```typescript\ndescribe('Vault events', () =\u003e {\n  it('should emit create event on file creation', async () =\u003e {\n    const events: any[] = []\n    vault.on('create', (file) =\u003e events.push({ type: 'create', file }))\n    \n    await vault.create('new.md', 'content')\n    \n    expect(events).toHaveLength(1)\n    expect(events[0].file.path).toBe('new.md')\n  })\n  \n  it('should emit modify event on file modification', async () =\u003e {})\n  it('should emit delete event on file deletion', async () =\u003e {})\n  it('should emit rename event with old path', async () =\u003e {\n    const events: any[] = []\n    vault.on('rename', (file, oldPath) =\u003e events.push({ file, oldPath }))\n    \n    const file = await vault.create('old.md', 'content')\n    await vault.rename(file, 'new.md')\n    \n    expect(events[0].oldPath).toBe('old.md')\n    expect(events[0].file.path).toBe('new.md')\n  })\n  \n  it('should allow unsubscribing from events', () =\u003e {})\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:24.519548-06:00","updated_at":"2026-01-05T10:08:50.099405-06:00","closed_at":"2026-01-05T10:08:50.099405-06:00","close_reason":"RED phase tests written and verified failing"}
{"id":"obsidian-4bc","title":"GREEN: MetadataCache - Event system implementation","description":"\n# GREEN Phase: MetadataCache Events\n\n```typescript\n// Add to src/metadata/cache.ts\n\nprivate setupVaultListeners(): void {\n  this.vault.on('create', async (file: TFile) =\u003e {\n    if (file.extension === 'md') {\n      await this.indexFile(file)\n    }\n  })\n  \n  this.vault.on('modify', async (file: TFile) =\u003e {\n    if (file.extension === 'md') {\n      await this.indexFile(file)\n    }\n  })\n  \n  this.vault.on('delete', (file: TFile) =\u003e {\n    this.cache.delete(file.path)\n    delete this.resolvedLinks[file.path]\n    delete this.unresolvedLinks[file.path]\n    this.trigger('deleted', file, this.cache.get(file.path))\n  })\n  \n  this.vault.on('rename', async (file: TFile, oldPath: string) =\u003e {\n    // Remove old cache entry\n    const oldMetadata = this.cache.get(oldPath)\n    this.cache.delete(oldPath)\n    delete this.resolvedLinks[oldPath]\n    delete this.unresolvedLinks[oldPath]\n    \n    // Re-index at new path\n    if (file.extension === 'md') {\n      await this.indexFile(file)\n    }\n    \n    // Update all files that linked to old path\n    this.reindexBacklinks(oldPath)\n  })\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:52.126069-06:00","updated_at":"2026-01-05T11:43:47.730907-06:00","closed_at":"2026-01-05T11:43:47.730907-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-4bc","depends_on_id":"obsidian-m8a","type":"blocks","created_at":"2026-01-05T09:48:14.094646-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-4y2","title":"GREEN: Client - ObsidianClient implementation","description":"\n# GREEN Phase: ObsidianClient\n\n```typescript\n// src/client/client.ts\nexport interface ClientOptions {\n  vaultPath?: string\n  backend?: 'filesystem' | 'memory' | 'rest'\n  initialFiles?: Record\u003cstring, string\u003e\n  restApiUrl?: string\n  restApiKey?: string\n}\n\nexport interface Note {\n  file: TFile\n  content: string\n  metadata: CachedMetadata\n  backlinks: BacklinkResult[]\n}\n\nexport class ObsidianClient {\n  vault\\!: Vault\n  metadataCache\\!: MetadataCache\n  graph\\!: GraphEngine\n  search\\!: SearchEngine\n  \n  private backend\\!: VaultBackend\n  \n  constructor(private options: ClientOptions) {}\n  \n  async initialize(): Promise\u003cvoid\u003e {\n    // Create backend\n    this.backend = this.createBackend()\n    \n    // Initialize components\n    this.vault = new Vault(this.backend)\n    this.metadataCache = new MetadataCache(this.vault)\n    await this.metadataCache.initialize()\n    \n    this.graph = new GraphEngine(this.metadataCache)\n    this.search = new SearchEngine(this.vault, this.metadataCache)\n  }\n  \n  async getNote(path: string): Promise\u003cNote\u003e {\n    const file = this.vault.getFileByPath(path)\n    if (\\!file) throw new Error(`Note not found: ${path}`)\n    \n    const content = await this.vault.read(file)\n    const metadata = this.metadataCache.getFileCache(file) ?? {}\n    const backlinks = this.graph.getBacklinks(path)\n    \n    return { file, content, metadata, backlinks }\n  }\n  \n  async createNote(\n    path: string,\n    content: string,\n    frontmatter?: Record\u003cstring, any\u003e\n  ): Promise\u003cTFile\u003e {\n    let finalContent = content\n    \n    if (frontmatter) {\n      const yaml = this.serializeFrontmatter(frontmatter)\n      finalContent = `---\\n${yaml}---\\n\\n${content}`\n    }\n    \n    return this.vault.create(path, finalContent)\n  }\n  \n  async updateNote(path: string, content: string): Promise\u003cvoid\u003e {\n    const file = this.vault.getFileByPath(path)\n    if (\\!file) throw new Error(`Note not found: ${path}`)\n    await this.vault.modify(file, content)\n  }\n  \n  async updateFrontmatter(\n    path: string,\n    updates: Record\u003cstring, any\u003e\n  ): Promise\u003cvoid\u003e {\n    const file = this.vault.getFileByPath(path)\n    if (\\!file) throw new Error(`Note not found: ${path}`)\n    \n    await this.vault.process(file, content =\u003e {\n      const existing = parseFrontmatter(content) ?? {}\n      const merged = { ...existing, ...updates }\n      delete merged.position\n      \n      const yaml = this.serializeFrontmatter(merged)\n      const body = getContentWithoutFrontmatter(content)\n      \n      return `---\\n${yaml}---\\n\\n${body}`\n    })\n  }\n  \n  private createBackend(): VaultBackend {\n    switch (this.options.backend) {\n      case 'memory':\n        return new MemoryBackend(this.options.initialFiles)\n      case 'rest':\n        return new RestApiBackend(this.options.restApiUrl\\!, this.options.restApiKey\\!)\n      case 'filesystem':\n      default:\n        return new FileSystemBackend(this.options.vaultPath\\!)\n    }\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:48:46.946376-06:00","updated_at":"2026-01-05T11:43:47.731513-06:00","closed_at":"2026-01-05T11:43:47.731513-06:00","close_reason":"Implementation complete, all tests pass"}
{"id":"obsidian-56d","title":"REFACTOR: MetadataCache - optimization and indexing","description":"\n# REFACTOR Phase: MetadataCache\n\n## Tasks\n- [ ] Add debounced indexing for rapid file changes\n- [ ] Implement incremental link graph updates\n- [ ] Add index persistence (save/load cache)\n- [ ] Optimize backlink lookup with reverse index\n- [ ] Add cache statistics and metrics\n- [ ] Comprehensive JSDoc\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Index rebuild is O(n) for n files\n- [ ] Backlink lookup is O(1)\n","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T09:41:58.646584-06:00","updated_at":"2026-01-05T14:01:12.300752-06:00","dependencies":[{"issue_id":"obsidian-56d","depends_on_id":"obsidian-s0i","type":"blocks","created_at":"2026-01-05T09:48:19.333239-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-56d","depends_on_id":"obsidian-20d","type":"blocks","created_at":"2026-01-05T09:48:24.579987-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-56d","depends_on_id":"obsidian-4bc","type":"blocks","created_at":"2026-01-05T09:48:29.839698-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-57r","title":"Epic: MCP Module - Model Context Protocol","description":"\n# MCP Module\n\nModel Context Protocol server for AI agent access to Obsidian vaults.\n\n## Components\n- MCP Server (stdio transport)\n- Tool definitions (search, read, write, graph)\n- Tool handlers (implementation)\n\n## Key Features\n- Full MCP protocol compliance\n- Read and write tools\n- Graph traversal tools\n- AI-optimized context tools\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-05T09:48:43.905149-06:00","updated_at":"2026-01-05T09:48:43.905149-06:00"}
{"id":"obsidian-663","title":"REFACTOR: Graph module - optimization and caching","description":"\n# REFACTOR Phase: Graph Module\n\n## Tasks\n- [ ] Cache backlink lookups with reverse index\n- [ ] Implement incremental cluster updates\n- [ ] Add graph visualization export (DOT, JSON)\n- [ ] Optimize path finding for large vaults\n- [ ] Add PageRank-style importance scoring\n- [ ] Comprehensive JSDoc\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] O(1) backlink lookup\n- [ ] Graph export in multiple formats\n","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T09:42:08.400635-06:00","updated_at":"2026-01-05T14:01:12.300143-06:00","dependencies":[{"issue_id":"obsidian-663","depends_on_id":"obsidian-v3f","type":"blocks","created_at":"2026-01-05T09:48:58.365749-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-663","depends_on_id":"obsidian-8sx","type":"blocks","created_at":"2026-01-05T09:49:03.59354-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-663","depends_on_id":"obsidian-tkg","type":"blocks","created_at":"2026-01-05T09:49:08.84531-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-6fw","title":"GREEN: Search - Engine implementation","description":"\n# GREEN Phase: Search Engine\n\n```typescript\n// src/search/engine.ts\nexport interface SearchOptions {\n  includeContent?: boolean\n  limit?: number\n  sortBy?: 'relevance' | 'modified' | 'created'\n  filter?: {\n    folder?: string\n    tags?: string[]\n    extension?: string\n  }\n}\n\nexport interface FileSearchResult {\n  file: TFile\n  score: number\n  matches: SearchMatches\n  context?: string\n}\n\nexport class SearchEngine {\n  constructor(\n    private vault: Vault,\n    private metadataCache: MetadataCache\n  ) {}\n  \n  async search(query: string, options: SearchOptions = {}): Promise\u003cFileSearchResult[]\u003e {\n    const searchFn = query.includes(' ') \n      ? prepareSimpleSearch(query)\n      : prepareFuzzySearch(query)\n    \n    let files = this.vault.getMarkdownFiles()\n    \n    // Apply filters\n    if (options.filter?.folder) {\n      files = files.filter(f =\u003e f.path.startsWith(options.filter\\!.folder\\!))\n    }\n    if (options.filter?.tags) {\n      files = files.filter(f =\u003e this.hasAnyTag(f, options.filter\\!.tags\\!))\n    }\n    \n    // Search content\n    const results: FileSearchResult[] = []\n    \n    for (const file of files) {\n      const content = await this.vault.cachedRead(file)\n      const searchResult = searchFn(content)\n      \n      if (searchResult || \\!query) {  // Empty query = all files match\n        results.push({\n          file,\n          score: searchResult?.score ?? 0,\n          matches: searchResult?.matches ?? [],\n          context: options.includeContent ? this.getContext(content, searchResult?.matches) : undefined\n        })\n      }\n    }\n    \n    // Sort\n    results.sort((a, b) =\u003e b.score - a.score)\n    \n    // Limit\n    if (options.limit) {\n      return results.slice(0, options.limit)\n    }\n    \n    return results\n  }\n  \n  findByTag(tag: string): TFile[] {\n    const normalizedTag = tag.startsWith('#') ? tag : '#' + tag\n    \n    return this.vault.getMarkdownFiles().filter(file =\u003e {\n      const metadata = this.metadataCache.getFileCache(file)\n      return metadata?.tags?.some(t =\u003e t.tag === normalizedTag || t.tag.startsWith(normalizedTag + '/'))\n    })\n  }\n  \n  findByProperty(key: string, value?: any): TFile[] {\n    return this.vault.getMarkdownFiles().filter(file =\u003e {\n      const metadata = this.metadataCache.getFileCache(file)\n      if (\\!metadata?.frontmatter) return false\n      if (value === undefined) return key in metadata.frontmatter\n      return metadata.frontmatter[key] === value\n    })\n  }\n  \n  findByLink(targetPath: string): TFile[] {\n    const results: TFile[] = []\n    \n    for (const [sourcePath, targets] of Object.entries(this.metadataCache.resolvedLinks)) {\n      if (targets[targetPath]) {\n        const file = this.vault.getFileByPath(sourcePath)\n        if (file) results.push(file)\n      }\n    }\n    \n    return results\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:42:07.920602-06:00","updated_at":"2026-01-05T10:42:28.668811-06:00","closed_at":"2026-01-05T10:42:28.668811-06:00","close_reason":"Implementation completed, tests pass","dependencies":[{"issue_id":"obsidian-6fw","depends_on_id":"obsidian-x67","type":"blocks","created_at":"2026-01-05T09:49:31.83621-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-6lp","title":"[obsidian] Add files field to package.json for npm publishing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T12:09:44.114909-06:00","updated_at":"2026-01-05T12:31:03.633905-06:00","closed_at":"2026-01-05T12:31:03.633905-06:00","close_reason":"Added files, bin, repository, author, homepage fields to package.json. Added prepublishOnly script. Added shebang to CLI entry."}
{"id":"obsidian-6mo","title":"[obsidian] Add README.md documentation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T12:09:31.073909-06:00","updated_at":"2026-01-05T12:29:28.505402-06:00","closed_at":"2026-01-05T12:29:28.505402-06:00","close_reason":"Implementation complete"}
{"id":"obsidian-6r1","title":"GREEN: MCP - Tool handlers implementation","description":"\n# GREEN Phase: MCP Tool Handlers\n\n```typescript\n// src/mcp/handlers.ts\nexport const toolHandlers: Record\u003cstring, ToolHandler\u003e = {\n  vault_search: handleVaultSearch,\n  vault_list: handleVaultList,\n  note_read: handleNoteRead,\n  note_create: handleNoteCreate,\n  note_update: handleNoteUpdate,\n  note_append: handleNoteAppend,\n  frontmatter_update: handleFrontmatterUpdate,\n  graph_backlinks: handleGraphBacklinks,\n  graph_forward_links: handleGraphForwardLinks,\n  graph_neighbors: handleGraphNeighbors,\n  vault_context: handleVaultContext\n}\n\nexport async function handleVaultSearch(\n  client: ObsidianClient,\n  args: { query: string; filter?: any; limit?: number }\n) {\n  const results = await client.search.search(args.query, {\n    filter: args.filter,\n    limit: args.limit ?? 20\n  })\n  \n  return {\n    results: results.map(r =\u003e ({\n      path: r.file.path,\n      score: r.score,\n      excerpt: r.context\n    }))\n  }\n}\n\nexport async function handleNoteRead(\n  client: ObsidianClient,\n  args: { path: string; includeBacklinks?: boolean }\n) {\n  const note = await client.getNote(args.path)\n  \n  return {\n    path: note.file.path,\n    content: note.content,\n    metadata: {\n      tags: note.metadata.tags?.map(t =\u003e t.tag),\n      links: note.metadata.links?.map(l =\u003e l.link),\n      frontmatter: note.metadata.frontmatter\n    },\n    backlinks: args.includeBacklinks\n      ? note.backlinks.map(b =\u003e ({\n          path: b.file.path,\n          context: b.context\n        }))\n      : undefined\n  }\n}\n\nexport async function handleNoteCreate(\n  client: ObsidianClient,\n  args: { path: string; content: string; frontmatter?: any }\n) {\n  const file = await client.createNote(args.path, args.content, args.frontmatter)\n  return { created: true, path: file.path }\n}\n\nexport async function handleGraphBacklinks(\n  client: ObsidianClient,\n  args: { path: string; includeContext?: boolean }\n) {\n  const backlinks = client.graph.getBacklinks(args.path)\n  \n  return {\n    backlinks: backlinks.map(b =\u003e ({\n      path: b.file.path,\n      linkCount: b.links.length,\n      context: args.includeContext ? b.context : undefined\n    }))\n  }\n}\n\nexport async function handleVaultContext(\n  client: ObsidianClient,\n  args: { scope: string; focus?: string; maxTokens?: number }\n) {\n  return client.getContext({\n    scope: args.scope as any,\n    focus: args.focus,\n    maxTokens: args.maxTokens\n  })\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:15.686913-06:00","updated_at":"2026-01-05T12:16:05.513041-06:00","closed_at":"2026-01-05T12:16:05.513041-06:00","close_reason":"Implementation complete, all tests pass"}
{"id":"obsidian-6t1","title":"GREEN: Implement MCP limit and maxTokens parameters","description":"MCP tools.ts defines limit (vault_search) and maxTokens (vault_context) parameters but handlers ignore them. Implement the functionality.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T12:55:40.155526-06:00","updated_at":"2026-01-05T13:06:04.714853-06:00","closed_at":"2026-01-05T13:06:04.714853-06:00","close_reason":"Fixed, all tests pass"}
{"id":"obsidian-7hq","title":"RED: MCP handlers use create() instead of modify() for updates","description":"handleNoteUpdate() and handleNoteAppend() in handlers.ts use vault.create() instead of vault.modify(). This could cause data loss or unexpected behavior when updating existing files.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-05T13:21:19.026595-06:00","updated_at":"2026-01-05T13:38:31.043605-06:00","closed_at":"2026-01-05T13:38:31.043605-06:00","close_reason":"Fixed - MCP handlers now use vault.modify() instead of create() for updates"}
{"id":"obsidian-7hw","title":"GREEN: Fix Graph.getAllNodes() missing target-only nodes","description":"graph.ts getAllNodes() only returns files with outgoing links. Files that are only link targets are missed in stats, clusters, and orphan detection.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-05T12:55:34.023419-06:00","updated_at":"2026-01-05T13:06:04.71442-06:00","closed_at":"2026-01-05T13:06:04.71442-06:00","close_reason":"Fixed, all tests pass"}
{"id":"obsidian-83y","title":"CRITICAL: Add Node.js engine requirement","description":"package.json missing engines field. Package uses ES2022 features requiring Node 18+. Add: engines: { node: '\u003e=18.0.0' }","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-05T13:20:59.21664-06:00","updated_at":"2026-01-05T13:38:18.362745-06:00","closed_at":"2026-01-05T13:38:18.362745-06:00","close_reason":"Fixed - Added engines field to package.json requiring Node.js 18+"}
{"id":"obsidian-8og","title":"RED: MCP - Tool handlers tests","description":"\n# RED Phase: MCP Tool Handlers Tests\n\n```typescript\n// test/mcp/handlers.test.ts\ndescribe('Tool handlers', () =\u003e {\n  let client: ObsidianClient\n  \n  beforeEach(async () =\u003e {\n    client = new ObsidianClient({\n      backend: 'memory',\n      initialFiles: {\n        'projects/alpha.md': '# Alpha\\n#project\\n[[beta]]',\n        'projects/beta.md': '# Beta\\n#project',\n        'notes/meeting.md': '# Meeting\\nDiscussed [[projects/alpha]]'\n      }\n    })\n    await client.initialize()\n  })\n  \n  describe('vault_search', () =\u003e {\n    it('should search notes by query', async () =\u003e {\n      const result = await handleVaultSearch(client, { query: 'alpha' })\n      \n      expect(result.results).toHaveLength(2)\n      expect(result.results[0].path).toBe('projects/alpha.md')\n    })\n    \n    it('should filter by tags', async () =\u003e {\n      const result = await handleVaultSearch(client, {\n        query: '',\n        filter: { tags: ['project'] }\n      })\n      \n      expect(result.results).toHaveLength(2)\n    })\n  })\n  \n  describe('note_read', () =\u003e {\n    it('should read note content', async () =\u003e {\n      const result = await handleNoteRead(client, { path: 'projects/alpha.md' })\n      \n      expect(result.content).toBe('# Alpha\\n#project\\n[[beta]]')\n      expect(result.metadata).toBeDefined()\n    })\n    \n    it('should include backlinks when requested', async () =\u003e {\n      const result = await handleNoteRead(client, {\n        path: 'projects/alpha.md',\n        includeBacklinks: true\n      })\n      \n      expect(result.backlinks).toHaveLength(1)\n      expect(result.backlinks[0].path).toBe('notes/meeting.md')\n    })\n  })\n  \n  describe('note_create', () =\u003e {\n    it('should create new note', async () =\u003e {\n      const result = await handleNoteCreate(client, {\n        path: 'new.md',\n        content: '# New Note'\n      })\n      \n      expect(result.created).toBe(true)\n      expect(result.path).toBe('new.md')\n      \n      const note = await client.getNote('new.md')\n      expect(note.content).toBe('# New Note')\n    })\n    \n    it('should create with frontmatter', async () =\u003e {\n      const result = await handleNoteCreate(client, {\n        path: 'new.md',\n        content: '# New',\n        frontmatter: { status: 'draft' }\n      })\n      \n      const note = await client.getNote('new.md')\n      expect(note.metadata.frontmatter?.status).toBe('draft')\n    })\n  })\n  \n  describe('graph_backlinks', () =\u003e {\n    it('should return backlinks for note', async () =\u003e {\n      const result = await handleGraphBacklinks(client, {\n        path: 'projects/alpha.md'\n      })\n      \n      expect(result.backlinks).toHaveLength(1)\n    })\n    \n    it('should include context when requested', async () =\u003e {\n      const result = await handleGraphBacklinks(client, {\n        path: 'projects/alpha.md',\n        includeContext: true\n      })\n      \n      expect(result.backlinks[0].context).toBeDefined()\n    })\n  })\n  \n  describe('vault_context', () =\u003e {\n    it('should generate AI context', async () =\u003e {\n      const result = await handleVaultContext(client, {\n        scope: 'summary'\n      })\n      \n      expect(result.summary).toBeDefined()\n      expect(result.graphStats).toBeDefined()\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:08.650141-06:00","updated_at":"2026-01-05T10:33:52.179714-06:00","closed_at":"2026-01-05T10:33:52.179714-06:00","close_reason":"TDD tests written and verified failing"}
{"id":"obsidian-8s9","title":"GREEN: Vault - FileManager implementation","description":"\n# GREEN Phase: FileManager\n\n```typescript\n// src/vault/file-manager.ts\nexport class FileManager {\n  constructor(\n    private vault: Vault,\n    private metadataCache: MetadataCache\n  ) {}\n  \n  async renameFile(file: TFile, newPath: string): Promise\u003cvoid\u003e {\n    const oldPath = file.path\n    \n    // Find all files that link to this file\n    const backlinks = this.getBacklinks(file)\n    \n    // Rename the file\n    await this.vault.rename(file, newPath)\n    \n    // Update all backlinks\n    for (const [sourcePath, links] of backlinks) {\n      await this.vault.process(\n        this.vault.getFileByPath(sourcePath)!,\n        content =\u003e this.updateLinks(content, oldPath, newPath)\n      )\n    }\n  }\n  \n  generateMarkdownLink(\n    file: TFile,\n    sourcePath: string,\n    subpath?: string,\n    alias?: string\n  ): string {\n    const linkPath = this.getRelativePath(file.path, sourcePath)\n    const link = subpath ? \\`\\${linkPath}\\${subpath}\\` : linkPath\n    return alias ? \\`[[\\${link}|\\${alias}]]\\` : \\`[[\\${link}]]\\`\n  }\n  \n  async processFrontMatter(\n    file: TFile,\n    fn: (frontmatter: any) =\u003e void\n  ): Promise\u003cvoid\u003e {\n    // Atomic frontmatter update\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:43.506345-06:00","updated_at":"2026-01-05T11:43:47.729562-06:00","closed_at":"2026-01-05T11:43:47.729562-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-8s9","depends_on_id":"obsidian-tym","type":"blocks","created_at":"2026-01-05T09:47:36.258223-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-8sx","title":"GREEN: Graph - Traversal implementation","description":"\n# GREEN Phase: Graph Traversal\n\n```typescript\n// src/graph/traversal.ts\nexport function getNeighbors(\n  graph: GraphEngine,\n  startPath: string,\n  depth: number = 1,\n  limit?: number\n): TFile[] {\n  const visited = new Set\u003cstring\u003e([startPath])\n  const queue: { path: string; distance: number }[] = [{ path: startPath, distance: 0 }]\n  const neighbors: TFile[] = []\n  \n  while (queue.length \u003e 0) {\n    const { path, distance } = queue.shift()!\n    \n    if (distance \u003e depth) continue\n    if (limit \u0026\u0026 neighbors.length \u003e= limit) break\n    \n    // Get forward links\n    for (const link of graph.getForwardLinks(path)) {\n      const target = graph.resolveLink(link.link, path)\n      if (target \u0026\u0026 !visited.has(target.path)) {\n        visited.add(target.path)\n        neighbors.push(target)\n        if (distance \u003c depth) {\n          queue.push({ path: target.path, distance: distance + 1 })\n        }\n      }\n    }\n    \n    // Get backlinks\n    for (const backlink of graph.getBacklinks(path)) {\n      if (!visited.has(backlink.file.path)) {\n        visited.add(backlink.file.path)\n        neighbors.push(backlink.file)\n        if (distance \u003c depth) {\n          queue.push({ path: backlink.file.path, distance: distance + 1 })\n        }\n      }\n    }\n  }\n  \n  return neighbors\n}\n\nexport function findPath(\n  graph: GraphEngine,\n  from: string,\n  to: string\n): string[] | null {\n  // BFS for shortest path\n  const visited = new Set\u003cstring\u003e()\n  const queue: { path: string; route: string[] }[] = [\n    { path: from, route: [from] }\n  ]\n  \n  while (queue.length \u003e 0) {\n    const { path, route } = queue.shift()!\n    \n    if (path === to) return route\n    if (visited.has(path)) continue\n    visited.add(path)\n    \n    // Explore neighbors\n    const neighbors = getNeighbors(graph, path, 1)\n    for (const neighbor of neighbors) {\n      if (!visited.has(neighbor.path)) {\n        queue.push({ path: neighbor.path, route: [...route, neighbor.path] })\n      }\n    }\n  }\n  \n  return null\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:48.629494-06:00","updated_at":"2026-01-05T10:42:28.671054-06:00","closed_at":"2026-01-05T10:42:28.671054-06:00","close_reason":"Implementation completed, tests pass","dependencies":[{"issue_id":"obsidian-8sx","depends_on_id":"obsidian-9wi","type":"blocks","created_at":"2026-01-05T09:48:47.556419-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-8vd","title":"REFACTOR: CLI module - UX and features","description":"\n# REFACTOR Phase: CLI Module\n\n## Tasks\n- [ ] Add interactive mode with prompts\n- [ ] Add watch command for file changes\n- [ ] Add graph export (DOT, JSON)\n- [ ] Colorized output\n- [ ] Progress indicators for long operations\n- [ ] Shell completions generation\n- [ ] Configuration file support (.obsidianrc)\n- [ ] Comprehensive --help text\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Excellent CLI UX\n- [ ] Shell completions for bash/zsh/fish\n","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T09:49:59.256163-06:00","updated_at":"2026-01-05T14:01:12.297664-06:00"}
{"id":"obsidian-9h8","title":"GREEN: Fix memory leak in FileManager frontmatterLock","description":"file-manager.ts frontmatterLock Map entries never cleaned up after processing. Causes memory leak over time with many file operations.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-05T12:55:27.74736-06:00","updated_at":"2026-01-05T13:06:04.714021-06:00","closed_at":"2026-01-05T13:06:04.714021-06:00","close_reason":"Fixed, all tests pass"}
{"id":"obsidian-9iv","title":"REFACTOR: Consolidate duplicate getFileTags functions","description":"getFileTags defined in 3 places: client/client.ts, client/context.ts, search/engine.ts. Extract to shared utility.","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T13:23:52.158717-06:00","updated_at":"2026-01-05T14:01:12.295301-06:00"}
{"id":"obsidian-9q3","title":"RED: CLI - Core CLI tests","description":"\n# RED Phase: CLI Core Tests\n\n```typescript\n// test/cli/cli.test.ts\ndescribe('CLI', () =\u003e {\n  let tempDir: string\n  \n  beforeEach(async () =\u003e {\n    tempDir = await createTempVault({\n      'notes/test.md': '# Test\\n#tag\\nContent',\n      'notes/other.md': '# Other\\n[[test]]'\n    })\n  })\n  \n  afterEach(async () =\u003e {\n    await fs.rm(tempDir, { recursive: true })\n  })\n  \n  describe('search command', () =\u003e {\n    it('should search notes by query', async () =\u003e {\n      const result = await runCli(['search', 'test', '--vault', tempDir])\n      \n      expect(result.exitCode).toBe(0)\n      expect(result.stdout).toContain('test.md')\n    })\n    \n    it('should filter by tags', async () =\u003e {\n      const result = await runCli(['search', '--tags', 'tag', '--vault', tempDir])\n      \n      expect(result.stdout).toContain('test.md')\n      expect(result.stdout).not.toContain('other.md')\n    })\n    \n    it('should output JSON when requested', async () =\u003e {\n      const result = await runCli(['search', 'test', '--json', '--vault', tempDir])\n      \n      const json = JSON.parse(result.stdout)\n      expect(json.results).toBeDefined()\n    })\n  })\n  \n  describe('read command', () =\u003e {\n    it('should read note content', async () =\u003e {\n      const result = await runCli(['read', 'notes/test.md', '--vault', tempDir])\n      \n      expect(result.exitCode).toBe(0)\n      expect(result.stdout).toContain('# Test')\n    })\n    \n    it('should include backlinks with --backlinks', async () =\u003e {\n      const result = await runCli(['read', 'notes/test.md', '--backlinks', '--vault', tempDir])\n      \n      expect(result.stdout).toContain('other.md')\n    })\n    \n    it('should error for non-existent file', async () =\u003e {\n      const result = await runCli(['read', 'missing.md', '--vault', tempDir])\n      \n      expect(result.exitCode).toBe(1)\n      expect(result.stderr).toContain('not found')\n    })\n  })\n  \n  describe('create command', () =\u003e {\n    it('should create new note', async () =\u003e {\n      const result = await runCli([\n        'create', 'notes/new.md',\n        '--content', '# New Note',\n        '--vault', tempDir\n      ])\n      \n      expect(result.exitCode).toBe(0)\n      \n      const content = await fs.readFile(path.join(tempDir, 'notes/new.md'), 'utf-8')\n      expect(content).toBe('# New Note')\n    })\n    \n    it('should add frontmatter with --tags', async () =\u003e {\n      const result = await runCli([\n        'create', 'notes/new.md',\n        '--content', '# New',\n        '--tags', 'foo,bar',\n        '--vault', tempDir\n      ])\n      \n      const content = await fs.readFile(path.join(tempDir, 'notes/new.md'), 'utf-8')\n      expect(content).toContain('tags:')\n    })\n  })\n  \n  describe('backlinks command', () =\u003e {\n    it('should list backlinks for note', async () =\u003e {\n      const result = await runCli(['backlinks', 'notes/test.md', '--vault', tempDir])\n      \n      expect(result.exitCode).toBe(0)\n      expect(result.stdout).toContain('other.md')\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:48:49.287783-06:00","updated_at":"2026-01-05T10:35:10.118928-06:00","closed_at":"2026-01-05T10:35:10.118928-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-9vr","title":"RED: CORS allows all origins in HTTP server","description":"Security issue: serve.ts uses 'origin: *' CORS config. Any website can make requests to localhost server. Fix: Make CORS origin configurable, default to restrictive.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-05T12:55:14.911838-06:00","updated_at":"2026-01-05T13:06:04.713041-06:00","closed_at":"2026-01-05T13:06:04.713041-06:00","close_reason":"Fixed, all tests pass"}
{"id":"obsidian-9wi","title":"RED: Graph - Traversal tests","description":"\n# RED Phase: Graph Traversal Tests\n\n```typescript\ndescribe('Graph traversal', () =\u003e {\n  describe('getNeighbors', () =\u003e {\n    it('should return 1-hop neighbors by default', () =\u003e {\n      const neighbors = graph.getNeighbors('hub.md')\n      expect(neighbors.map(n =\u003e n.path)).toEqual(\n        expect.arrayContaining(['spoke1.md', 'spoke2.md', 'spoke3.md'])\n      )\n    })\n    \n    it('should return n-hop neighbors with depth param', () =\u003e {\n      // spoke3 links to spoke1, so 2-hop from hub includes spoke3-\u003espoke1 path\n      const neighbors = graph.getNeighbors('spoke1.md', 2)\n      expect(neighbors.map(n =\u003e n.path)).toContain('hub.md')\n      expect(neighbors.map(n =\u003e n.path)).toContain('spoke3.md')\n    })\n    \n    it('should not include the source file', () =\u003e {\n      const neighbors = graph.getNeighbors('hub.md')\n      expect(neighbors.map(n =\u003e n.path)).not.toContain('hub.md')\n    })\n    \n    it('should respect limit parameter', () =\u003e {\n      const neighbors = graph.getNeighbors('hub.md', 1, 2)\n      expect(neighbors).toHaveLength(2)\n    })\n  })\n  \n  describe('findPath', () =\u003e {\n    it('should find shortest path between connected notes', () =\u003e {\n      const path = graph.findPath('spoke1.md', 'spoke2.md')\n      // spoke1 -\u003e hub -\u003e spoke2 (via backlinks)\n      expect(path).toBeDefined()\n      expect(path).toContain('hub.md')\n    })\n    \n    it('should return null for disconnected notes', () =\u003e {\n      const path = graph.findPath('orphan.md', 'hub.md')\n      expect(path).toBeNull()\n    })\n    \n    it('should return direct path for linked notes', () =\u003e {\n      const path = graph.findPath('spoke1.md', 'hub.md')\n      expect(path).toEqual(['spoke1.md', 'hub.md'])\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:42.175532-06:00","updated_at":"2026-01-05T10:09:22.715347-06:00","closed_at":"2026-01-05T10:09:22.715347-06:00","close_reason":"RED phase Graph traversal tests written and verified failing"}
{"id":"obsidian-au3","title":"GREEN: CLI - Core CLI implementation","description":"\n# GREEN Phase: CLI Core\n\n```typescript\n// src/cli/index.ts\nimport { cac } from 'cac'\nimport { ObsidianClient } from '../client'\n\nconst cli = cac('obsidian')\n\ncli.option('--vault \u003cpath\u003e', 'Path to Obsidian vault')\ncli.option('--json', 'Output as JSON')\n\ncli\n  .command('search \u003cquery\u003e', 'Search notes in vault')\n  .option('--tags \u003ctags\u003e', 'Filter by tags (comma-separated)')\n  .option('--folder \u003cfolder\u003e', 'Filter by folder')\n  .option('--limit \u003cn\u003e', 'Limit results', { default: 20 })\n  .action(async (query, options) =\u003e {\n    const client = await createClient(options)\n    \n    const results = await client.search.search(query, {\n      filter: {\n        tags: options.tags?.split(','),\n        folder: options.folder\n      },\n      limit: options.limit\n    })\n    \n    if (options.json) {\n      console.log(JSON.stringify({ results }, null, 2))\n    } else {\n      for (const r of results) {\n        console.log(\\`\\${r.file.path} (score: \\${r.score})\\`)\n      }\n    }\n  })\n\ncli\n  .command('read \u003cpath\u003e', 'Read note content')\n  .alias('cat')\n  .option('--backlinks', 'Include backlinks')\n  .action(async (notePath, options) =\u003e {\n    const client = await createClient(options)\n    \n    try {\n      const note = await client.getNote(notePath)\n      console.log(note.content)\n      \n      if (options.backlinks \u0026\u0026 note.backlinks.length \u003e 0) {\n        console.log('\\n--- Backlinks ---')\n        for (const bl of note.backlinks) {\n          console.log(\\`- \\${bl.file.path}\\`)\n        }\n      }\n    } catch {\n      console.error(\\`Note not found: \\${notePath}\\`)\n      process.exit(1)\n    }\n  })\n\ncli\n  .command('create \u003cpath\u003e', 'Create new note')\n  .option('--content \u003ccontent\u003e', 'Note content')\n  .option('--tags \u003ctags\u003e', 'Tags (comma-separated)')\n  .action(async (notePath, options) =\u003e {\n    const client = await createClient(options)\n    \n    const frontmatter = options.tags\n      ? { tags: options.tags.split(',') }\n      : undefined\n    \n    await client.createNote(notePath, options.content || '', frontmatter)\n    console.log(\\`Created: \\${notePath}\\`)\n  })\n\ncli\n  .command('backlinks \u003cpath\u003e', 'Show backlinks for note')\n  .action(async (notePath, options) =\u003e {\n    const client = await createClient(options)\n    const backlinks = client.graph.getBacklinks(notePath)\n    \n    if (backlinks.length === 0) {\n      console.log('No backlinks found')\n    } else {\n      for (const bl of backlinks) {\n        console.log(\\`\\${bl.file.path} (\\${bl.links.length} link(s))\\`)\n      }\n    }\n  })\n\nasync function createClient(options: any): Promise\u003cObsidianClient\u003e {\n  const vaultPath = options.vault || process.env.OBSIDIAN_VAULT || process.cwd()\n  const client = new ObsidianClient({ vaultPath, backend: 'filesystem' })\n  await client.initialize()\n  return client\n}\n\ncli.help()\ncli.version('1.0.0')\n\nexport function run() {\n  cli.parse()\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:48:59.068315-06:00","updated_at":"2026-01-05T12:03:39.30864-06:00","closed_at":"2026-01-05T12:03:39.30864-06:00","close_reason":"Implementation complete, all tests pass"}
{"id":"obsidian-bwi","title":"GREEN: Add path validation to MCP handlers","description":"MCP handlers.ts validateMarkdownPath checks for special chars but not '../' path traversal. Add validation to reject paths that escape vault root.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-05T12:55:47.304804-06:00","updated_at":"2026-01-05T13:06:04.715309-06:00","closed_at":"2026-01-05T13:06:04.715309-06:00","close_reason":"Fixed, all tests pass"}
{"id":"obsidian-byw","title":"GREEN: Vault - CRUD operation implementation","description":"\n# GREEN Phase: Vault CRUD\n\n```typescript\n// src/vault/vault.ts\nexport class Vault extends Events {\n  private cache = new Map\u003cstring, string\u003e()\n  private files = new Map\u003cstring, TFile\u003e()\n  \n  constructor(private backend: VaultBackend) {\n    super()\n    this.initialize()\n  }\n  \n  async read(file: TFile): Promise\u003cstring\u003e {\n    return this.backend.read(file.path)\n  }\n  \n  async cachedRead(file: TFile): Promise\u003cstring\u003e {\n    if (this.cache.has(file.path)) {\n      return this.cache.get(file.path)!\n    }\n    const content = await this.read(file)\n    this.cache.set(file.path, content)\n    return content\n  }\n  \n  async create(path: string, data: string): Promise\u003cTFile\u003e {\n    await this.backend.write(path, data)\n    const file = this.createTFile(path)\n    this.files.set(path, file)\n    this.trigger('create', file)\n    return file\n  }\n  \n  async modify(file: TFile, data: string): Promise\u003cvoid\u003e {\n    await this.backend.write(file.path, data)\n    this.cache.delete(file.path)\n    this.trigger('modify', file)\n  }\n  \n  async process(file: TFile, fn: (data: string) =\u003e string): Promise\u003cstring\u003e {\n    const content = await this.read(file)\n    const newContent = fn(content)\n    await this.modify(file, newContent)\n    return newContent\n  }\n  \n  // ... other methods\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:03.622043-06:00","updated_at":"2026-01-05T11:26:24.684327-06:00","closed_at":"2026-01-05T11:26:24.684327-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-byw","depends_on_id":"obsidian-2co","type":"blocks","created_at":"2026-01-05T09:47:20.57642-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-cb1","title":"RED: Client - Context generator tests","description":"\n# RED Phase: Context Generator Tests\n\n```typescript\n// test/client/context.test.ts\ndescribe('Context generator', () =\u003e {\n  let client: ObsidianClient\n  \n  beforeEach(async () =\u003e {\n    client = new ObsidianClient({\n      backend: 'memory',\n      initialFiles: {\n        'projects/alpha.md': '# Alpha\\n#project\\nActive project',\n        'projects/beta.md': '# Beta\\n#project #archived\\nOld project',\n        'notes/meeting.md': '# Meeting\\nDiscussed [[projects/alpha]]',\n        'daily/2024-01-01.md': '# Jan 1\\n#daily\\nWorked on [[projects/alpha]]'\n      }\n    })\n    await client.initialize()\n  })\n  \n  describe('getContext', () =\u003e {\n    it('should generate summary context', async () =\u003e {\n      const context = await client.getContext({ scope: 'summary' })\n      \n      expect(context.summary).toBeDefined()\n      expect(context.tagCloud).toBeDefined()\n      expect(context.graphStats).toBeDefined()\n    })\n    \n    it('should generate recent notes context', async () =\u003e {\n      const context = await client.getContext({ scope: 'recent' })\n      \n      expect(context.recentNotes).toBeDefined()\n      expect(context.recentNotes.length).toBeGreaterThan(0)\n    })\n    \n    it('should generate related notes context', async () =\u003e {\n      const context = await client.getContext({\n        scope: 'related',\n        focus: 'projects/alpha.md'\n      })\n      \n      expect(context.relatedNotes).toBeDefined()\n      // Should include meeting.md and daily note that link to alpha\n      expect(context.relatedNotes.map(n =\u003e n.file.path)).toContain('notes/meeting.md')\n    })\n    \n    it('should respect maxTokens limit', async () =\u003e {\n      const context = await client.getContext({\n        scope: 'summary',\n        maxTokens: 100\n      })\n      \n      // Context should be truncated to fit token limit\n      const estimatedTokens = JSON.stringify(context).length / 4\n      expect(estimatedTokens).toBeLessThanOrEqual(150) // Some buffer\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:11.876757-06:00","updated_at":"2026-01-05T10:35:10.120748-06:00","closed_at":"2026-01-05T10:35:10.120748-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-csj","title":"REFACTOR: MCP module - streaming and resources","description":"\n# REFACTOR Phase: MCP Module\n\n## Tasks\n- [ ] Add streaming responses for large content\n- [ ] Implement MCP resources (notes as resources)\n- [ ] Add MCP prompts (common query templates)\n- [ ] Rate limiting and throttling\n- [ ] Comprehensive error codes\n- [ ] Add tool usage metrics\n- [ ] JSDoc with examples\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Full MCP protocol compliance\n- [ ] Streaming for large vaults\n","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T09:49:36.989421-06:00","updated_at":"2026-01-05T14:01:12.298617-06:00"}
{"id":"obsidian-d2s","title":"GREEN: Vault - File discovery implementation","description":"\n# GREEN Phase: Vault Discovery\n\n```typescript\n// Add to src/vault/vault.ts\n\ngetFileByPath(path: string): TFile | null {\n  return this.files.get(path) ?? null\n}\n\ngetAbstractFileByPath(path: string): TAbstractFile | null {\n  return this.files.get(path) ?? this.folders.get(path) ?? null\n}\n\ngetMarkdownFiles(): TFile[] {\n  return Array.from(this.files.values())\n    .filter(f =\u003e f.extension === 'md')\n}\n\ngetFiles(): TFile[] {\n  return Array.from(this.files.values())\n}\n\ngetAllLoadedFiles(): TAbstractFile[] {\n  return [\n    ...this.files.values(),\n    ...this.folders.values()\n  ]\n}\n\ngetAllFolders(includeRoot = true): TFolder[] {\n  const folders = Array.from(this.folders.values())\n  return includeRoot ? folders : folders.filter(f =\u003e \\!f.isRoot())\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:17.463425-06:00","updated_at":"2026-01-05T11:26:24.68727-06:00","closed_at":"2026-01-05T11:26:24.68727-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-d2s","depends_on_id":"obsidian-x49","type":"blocks","created_at":"2026-01-05T09:47:25.814685-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-e8e","title":"GREEN: Vault - Event system implementation","description":"\n# GREEN Phase: Vault Events\n\n```typescript\n// src/vault/events.ts\nexport interface EventRef {\n  unsubscribe(): void\n}\n\nexport class Events {\n  private listeners = new Map\u003cstring, Set\u003cFunction\u003e\u003e()\n  \n  on(event: string, callback: Function): EventRef {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set())\n    }\n    this.listeners.get(event)!.add(callback)\n    \n    return {\n      unsubscribe: () =\u003e this.off(event, callback)\n    }\n  }\n  \n  off(event: string, callback: Function): void {\n    this.listeners.get(event)?.delete(callback)\n  }\n  \n  trigger(event: string, ...args: any[]): void {\n    this.listeners.get(event)?.forEach(cb =\u003e cb(...args))\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:29.969882-06:00","updated_at":"2026-01-05T11:33:10.233304-06:00","closed_at":"2026-01-05T11:33:10.233304-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-e8e","depends_on_id":"obsidian-407","type":"blocks","created_at":"2026-01-05T09:47:31.039868-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-ec1","title":"RED: isPathSafe allows dot-segment traversal","description":"isPathSafe() in handlers.ts rejects '../' but allows './foo/../../../etc/passwd'. Need to normalize path before checking segments, or reject any path containing '..' anywhere.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-05T13:21:37.03623-06:00","updated_at":"2026-01-05T13:38:24.517767-06:00","closed_at":"2026-01-05T13:38:24.517767-06:00","close_reason":"Fixed - isPathSafe now normalizes paths before checking"}
{"id":"obsidian-ei6","title":"GREEN: Search - Simple search implementation","description":"\n# GREEN Phase: Simple Search\n\n```typescript\n// src/search/simple.ts\nexport function prepareSimpleSearch(query: string): (text: string) =\u003e SearchResult | null {\n  const words = query.toLowerCase().split(/\\s+/).filter(Boolean)\n  \n  return (text: string): SearchResult | null =\u003e {\n    const lowerText = text.toLowerCase()\n    const matches: SearchMatches = []\n    let score = 0\n    \n    for (const word of words) {\n      // Match at word boundary\n      const regex = new RegExp(`\\\\b${escapeRegex(word)}`, 'gi')\n      const match = regex.exec(lowerText)\n      \n      if (\\!match) {\n        return null  // All words must match\n      }\n      \n      matches.push([match.index, word.length])\n      score += word.length\n    }\n    \n    return { score, matches }\n  }\n}\n\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\\\$\u0026')\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:54.963646-06:00","updated_at":"2026-01-05T10:43:49.266537-06:00","closed_at":"2026-01-05T10:43:49.266537-06:00","close_reason":"Implementation completed, tests pass","dependencies":[{"issue_id":"obsidian-ei6","depends_on_id":"obsidian-3it","type":"blocks","created_at":"2026-01-05T09:49:26.519946-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-eqh","title":"Epic: Vault Module - Core Vault Operations","description":"\n# Vault Module\n\nCore vault abstraction that mirrors Obsidian's Vault class. Provides file operations, discovery, and event emission.\n\n## Components\n- Vault class (main interface)\n- FileManager (safe operations with link updates)\n- Event system (create, modify, delete, rename)\n\n## Key Methods\n- read/cachedRead/readBinary\n- create/modify/append/process\n- delete/trash/rename/copy\n- getFileByPath/getMarkdownFiles/getAllFolders\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-05T09:40:23.335257-06:00","updated_at":"2026-01-05T09:40:23.335257-06:00"}
{"id":"obsidian-ezh","title":"RED: Graph - Analysis tests","description":"\n# RED Phase: Graph Analysis Tests\n\n```typescript\ndescribe('Graph analysis', () =\u003e {\n  describe('getOrphans', () =\u003e {\n    it('should return notes with no incoming or outgoing links', () =\u003e {\n      const orphans = graph.getOrphans()\n      expect(orphans.map(o =\u003e o.path)).toEqual(['orphan.md'])\n    })\n  })\n  \n  describe('getDeadLinks', () =\u003e {\n    it('should return links to non-existent files', async () =\u003e {\n      await vault.create('broken.md', 'Link to [[missing]] and [[also-missing]]')\n      await cache.indexFile(vault.getFileByPath('broken.md')!)\n      \n      const deadLinks = graph.getDeadLinks()\n      expect(deadLinks).toHaveLength(2)\n      expect(deadLinks.map(d =\u003e d.link)).toContain('missing')\n    })\n  })\n  \n  describe('getMostLinked', () =\u003e {\n    it('should return files sorted by backlink count', () =\u003e {\n      const mostLinked = graph.getMostLinked(3)\n      \n      expect(mostLinked[0].file.path).toBe('hub.md')\n      expect(mostLinked[0].count).toBe(4) // 4 total links to hub\n    })\n  })\n  \n  describe('getClusters', () =\u003e {\n    it('should return connected components', () =\u003e {\n      const clusters = graph.getClusters()\n      \n      // Should have 2 clusters: connected notes + orphan\n      expect(clusters).toHaveLength(2)\n      expect(clusters.find(c =\u003e c.length === 1)?.[0].path).toBe('orphan.md')\n    })\n  })\n  \n  describe('getStats', () =\u003e {\n    it('should return graph statistics', () =\u003e {\n      const stats = graph.getStats()\n      \n      expect(stats.totalNodes).toBe(5)\n      expect(stats.totalEdges).toBeGreaterThan(0)\n      expect(stats.orphanCount).toBe(1)\n      expect(stats.averageDegree).toBeGreaterThan(0)\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:56.014492-06:00","updated_at":"2026-01-05T10:35:10.121461-06:00","closed_at":"2026-01-05T10:35:10.121461-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-f8m","title":"GREEN: CLI - MCP command implementation","description":"\n# GREEN Phase: CLI MCP Command\n\n```typescript\n// src/cli/mcp.ts\nimport * as readline from 'readline'\nimport { createMcpServer } from '../mcp'\n\ncli\n  .command('mcp', 'Start MCP server on stdio')\n  .action(async (options) =\u003e {\n    const client = await createClient(options)\n    const server = createMcpServer({ client })\n    \n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n      terminal: false\n    })\n    \n    rl.on('line', async (line) =\u003e {\n      try {\n        const request = JSON.parse(line)\n        const response = await server.handleRequest(request)\n        console.log(JSON.stringify(response))\n      } catch (err) {\n        console.log(JSON.stringify({\n          jsonrpc: '2.0',\n          id: null,\n          error: { code: -32700, message: 'Parse error' }\n        }))\n      }\n    })\n    \n    // Signal ready\n    console.error('obsidian.do MCP server started')\n  })\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:52.776337-06:00","updated_at":"2026-01-05T12:29:28.504275-06:00","closed_at":"2026-01-05T12:29:28.504275-06:00","close_reason":"Implementation complete"}
{"id":"obsidian-gxj","title":"REFACTOR: Consolidate duplicate Note interfaces","description":"client.ts and context.ts both define Note, VaultContext, ContextOptions interfaces with subtle differences. Consolidate to single source of truth.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T12:56:07.419202-06:00","updated_at":"2026-01-05T13:11:58.142893-06:00","closed_at":"2026-01-05T13:11:58.142893-06:00","close_reason":"Refactoring complete, all tests pass"}
{"id":"obsidian-hhi","title":"GREEN: Client - Context generator implementation","description":"\n# GREEN Phase: Context Generator\n\n```typescript\n// src/client/context.ts\nexport interface ContextOptions {\n  scope: 'summary' | 'recent' | 'related'\n  focus?: string\n  maxTokens?: number\n}\n\nexport interface VaultContext {\n  summary: string\n  recentNotes: Note[]\n  relatedNotes: Note[]\n  tagCloud: { tag: string; count: number }[]\n  graphStats: GraphStats\n}\n\nexport interface GraphStats {\n  totalNotes: number\n  totalLinks: number\n  orphanCount: number\n  averageLinks: number\n}\n\nexport async function generateContext(\n  client: ObsidianClient,\n  options: ContextOptions\n): Promise\u003cVaultContext\u003e {\n  const context: VaultContext = {\n    summary: '',\n    recentNotes: [],\n    relatedNotes: [],\n    tagCloud: [],\n    graphStats: getGraphStats(client)\n  }\n  \n  switch (options.scope) {\n    case 'summary':\n      context.summary = generateSummary(client)\n      context.tagCloud = getTagCloud(client)\n      break\n      \n    case 'recent':\n      context.recentNotes = await getRecentNotes(client, 10)\n      break\n      \n    case 'related':\n      if (options.focus) {\n        context.relatedNotes = await getRelatedNotes(client, options.focus)\n      }\n      break\n  }\n  \n  // Truncate if needed\n  if (options.maxTokens) {\n    return truncateContext(context, options.maxTokens)\n  }\n  \n  return context\n}\n\nfunction getGraphStats(client: ObsidianClient): GraphStats {\n  const files = client.vault.getMarkdownFiles()\n  const { resolvedLinks } = client.metadataCache\n  \n  let totalLinks = 0\n  for (const targets of Object.values(resolvedLinks)) {\n    totalLinks += Object.values(targets).reduce((a, b) =\u003e a + b, 0)\n  }\n  \n  return {\n    totalNotes: files.length,\n    totalLinks,\n    orphanCount: client.graph.getOrphans().length,\n    averageLinks: files.length ? totalLinks / files.length : 0\n  }\n}\n\nfunction getTagCloud(client: ObsidianClient): { tag: string; count: number }[] {\n  const tagCounts = new Map\u003cstring, number\u003e()\n  \n  for (const file of client.vault.getMarkdownFiles()) {\n    const metadata = client.metadataCache.getFileCache(file)\n    for (const tag of metadata?.tags ?? []) {\n      tagCounts.set(tag.tag, (tagCounts.get(tag.tag) ?? 0) + 1)\n    }\n  }\n  \n  return Array.from(tagCounts.entries())\n    .map(([tag, count]) =\u003e ({ tag, count }))\n    .sort((a, b) =\u003e b.count - a.count)\n}\n\nasync function getRelatedNotes(\n  client: ObsidianClient,\n  focusPath: string\n): Promise\u003cNote[]\u003e {\n  const neighbors = client.graph.getNeighbors(focusPath, 2, 20)\n  return Promise.all(neighbors.map(f =\u003e client.getNote(f.path)))\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:34.396715-06:00","updated_at":"2026-01-05T12:16:05.515043-06:00","closed_at":"2026-01-05T12:16:05.515043-06:00","close_reason":"Implementation complete, all tests pass"}
{"id":"obsidian-ifa","title":"REFACTOR: Remove dead code and unused parameters","description":"Remove: updateLinksToRenamedFile (cache.ts), serializeFrontmatter (client.ts), unused file param in getFileTags, unused parser constructor param in MetadataCache.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T12:56:00.827443-06:00","updated_at":"2026-01-05T13:11:58.142155-06:00","closed_at":"2026-01-05T13:11:58.142155-06:00","close_reason":"Refactoring complete, all tests pass"}
{"id":"obsidian-in3","title":"RED: CLI - Serve command tests","description":"\n# RED Phase: CLI Serve Command Tests\n\n```typescript\n// test/cli/serve.test.ts\ndescribe('serve command', () =\u003e {\n  let tempDir: string\n  let serverProcess: ChildProcess\n  \n  beforeEach(async () =\u003e {\n    tempDir = await createTempVault({\n      'test.md': '# Test'\n    })\n  })\n  \n  afterEach(async () =\u003e {\n    serverProcess?.kill()\n    await fs.rm(tempDir, { recursive: true })\n  })\n  \n  it('should start HTTP server', async () =\u003e {\n    serverProcess = spawn('node', [\n      cliPath, 'serve',\n      '--vault', tempDir,\n      '--port', '0'  // Random port\n    ])\n    \n    // Wait for server to start\n    const port = await waitForServerStart(serverProcess)\n    \n    const response = await fetch(\\`http://localhost:\\${port}/health\\`)\n    expect(response.ok).toBe(true)\n  })\n  \n  it('should serve search endpoint', async () =\u003e {\n    serverProcess = spawn('node', [cliPath, 'serve', '--vault', tempDir, '--port', '0'])\n    const port = await waitForServerStart(serverProcess)\n    \n    const response = await fetch(\\`http://localhost:\\${port}/api/search?q=test\\`)\n    const data = await response.json()\n    \n    expect(data.results).toBeDefined()\n  })\n  \n  it('should serve note read endpoint', async () =\u003e {\n    serverProcess = spawn('node', [cliPath, 'serve', '--vault', tempDir, '--port', '0'])\n    const port = await waitForServerStart(serverProcess)\n    \n    const response = await fetch(\\`http://localhost:\\${port}/api/notes/test.md\\`)\n    const data = await response.json()\n    \n    expect(data.content).toBe('# Test')\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:08.350926-06:00","updated_at":"2026-01-05T10:35:10.122829-06:00","closed_at":"2026-01-05T10:35:10.122829-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-jce","title":"REFACTOR: Add backlink index for O(1) lookup","description":"GraphEngine and Graph iterate all resolvedLinks on every getBacklinks() call - O(n). Build inverted index (target-\u003esources) for O(1) lookups.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T12:56:13.850759-06:00","updated_at":"2026-01-05T13:11:58.143398-06:00","closed_at":"2026-01-05T13:11:58.143398-06:00","close_reason":"Refactoring complete, all tests pass"}
{"id":"obsidian-jcl","title":"REFACTOR: Make ObsidianClient properties readonly","description":"vault, metadataCache, graph, search properties should be readonly to prevent external mutation. Add readonly modifier.","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T13:23:31.932518-06:00","updated_at":"2026-01-05T14:01:12.296978-06:00"}
{"id":"obsidian-jtb","title":"[obsidian] Add LICENSE file","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T12:09:38.04848-06:00","updated_at":"2026-01-05T12:29:28.505842-06:00","closed_at":"2026-01-05T12:29:28.505842-06:00","close_reason":"Implementation complete"}
{"id":"obsidian-k0h","title":"GREEN: Remove dead CLI code","description":"cli/index.ts has functions throwing 'Not implemented': validateVaultPath(), showHelp(), routeToCommand(). Remove this dead code.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T13:22:14.949588-06:00","updated_at":"2026-01-05T13:38:44.338905-06:00","closed_at":"2026-01-05T13:38:44.338905-06:00","close_reason":"Fixed - Dead CLI code removed (validateVaultPath, showHelp, routeToCommand)"}
{"id":"obsidian-k2c","title":"REFACTOR: Client module - convenience methods and DX","description":"\n# REFACTOR Phase: Client Module\n\n## Tasks\n- [ ] Add query builder pattern for complex searches\n- [ ] Implement streaming for large context\n- [ ] Add caching layer for repeated queries\n- [ ] Builder pattern for note creation\n- [ ] Add event subscriptions for real-time updates\n- [ ] Comprehensive JSDoc with examples\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Excellent developer experience\n- [ ] Type-safe query builder\n","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T09:49:48.528136-06:00","updated_at":"2026-01-05T14:01:12.298175-06:00"}
{"id":"obsidian-lrj","title":"GREEN: Search - Fuzzy search implementation","description":"\n# GREEN Phase: Fuzzy Search\n\n```typescript\n// src/search/fuzzy.ts\nexport interface SearchResult {\n  score: number\n  matches: SearchMatches\n}\n\nexport type SearchMatches = [number, number][]  // [offset, length][]\n\nexport function prepareFuzzySearch(query: string): (text: string) =\u003e SearchResult | null {\n  const lowerQuery = query.toLowerCase()\n  const queryChars = [...lowerQuery]\n  \n  return (text: string): SearchResult | null =\u003e {\n    const lowerText = text.toLowerCase()\n    const matches: SearchMatches = []\n    let score = 0\n    let queryIndex = 0\n    let lastMatchIndex = -1\n    \n    for (let i = 0; i \u003c lowerText.length \u0026\u0026 queryIndex \u003c queryChars.length; i++) {\n      if (lowerText[i] === queryChars[queryIndex]) {\n        // Consecutive match bonus\n        if (lastMatchIndex === i - 1) {\n          score += 2\n        } else {\n          score += 1\n        }\n        \n        // Track match position\n        if (matches.length === 0 || matches[matches.length - 1][0] + matches[matches.length - 1][1] !== i) {\n          matches.push([i, 1])\n        } else {\n          matches[matches.length - 1][1]++\n        }\n        \n        lastMatchIndex = i\n        queryIndex++\n      }\n    }\n    \n    // All query chars must be found\n    if (queryIndex \u003c queryChars.length) {\n      return null\n    }\n    \n    // Bonus for exact matches\n    if (lowerText.includes(lowerQuery)) {\n      score += query.length * 2\n      // Find exact match position\n      const exactPos = lowerText.indexOf(lowerQuery)\n      matches.length = 0\n      matches.push([exactPos, query.length])\n    }\n    \n    return { score, matches }\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:41.78735-06:00","updated_at":"2026-01-05T10:42:28.671525-06:00","closed_at":"2026-01-05T10:42:28.671525-06:00","close_reason":"Implementation completed, tests pass","dependencies":[{"issue_id":"obsidian-lrj","depends_on_id":"obsidian-qu1","type":"blocks","created_at":"2026-01-05T09:49:21.270056-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-lxq","title":"RED: Graph - Backlinks tests","description":"\n# RED Phase: Graph Backlinks Tests\n\n```typescript\n// test/graph/engine.test.ts\ndescribe('GraphEngine', () =\u003e {\n  let vault: Vault\n  let cache: MetadataCache\n  let graph: GraphEngine\n  \n  beforeEach(async () =\u003e {\n    vault = createTestVault({\n      'hub.md': '# Hub',\n      'spoke1.md': '# Spoke 1\\nLink to [[hub]]',\n      'spoke2.md': '# Spoke 2\\nLink to [[hub]] twice [[hub]]',\n      'spoke3.md': '# Spoke 3\\nLink to [[hub]] and [[spoke1]]',\n      'orphan.md': '# Orphan\\nNo links here'\n    })\n    cache = new MetadataCache(vault)\n    await cache.initialize()\n    graph = new GraphEngine(cache)\n  })\n  \n  describe('getBacklinks', () =\u003e {\n    it('should return all files linking to target', () =\u003e {\n      const backlinks = graph.getBacklinks('hub.md')\n      \n      expect(backlinks).toHaveLength(3)\n      expect(backlinks.map(b =\u003e b.file.path)).toContain('spoke1.md')\n      expect(backlinks.map(b =\u003e b.file.path)).toContain('spoke2.md')\n      expect(backlinks.map(b =\u003e b.file.path)).toContain('spoke3.md')\n    })\n    \n    it('should include link context', () =\u003e {\n      const backlinks = graph.getBacklinks('hub.md')\n      const spoke2 = backlinks.find(b =\u003e b.file.path === 'spoke2.md')\n      \n      expect(spoke2?.links).toHaveLength(2) // Two links in spoke2\n    })\n    \n    it('should return empty array for file with no backlinks', () =\u003e {\n      const backlinks = graph.getBacklinks('orphan.md')\n      expect(backlinks).toHaveLength(0)\n    })\n  })\n  \n  describe('getForwardLinks', () =\u003e {\n    it('should return all files linked from source', () =\u003e {\n      const links = graph.getForwardLinks('spoke3.md')\n      \n      expect(links).toHaveLength(2)\n      expect(links.map(l =\u003e l.link)).toContain('hub')\n      expect(links.map(l =\u003e l.link)).toContain('spoke1')\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:28.629191-06:00","updated_at":"2026-01-05T10:36:05.735789-06:00","closed_at":"2026-01-05T10:36:05.735789-06:00","close_reason":"TDD tests written (test files exist)","dependencies":[{"issue_id":"obsidian-lxq","depends_on_id":"obsidian-s0i","type":"blocks","created_at":"2026-01-05T09:49:14.092478-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-m8a","title":"RED: MetadataCache - Event system tests","description":"\n# RED Phase: MetadataCache Events Tests\n\n```typescript\ndescribe('MetadataCache events', () =\u003e {\n  it('should emit changed event when file is indexed', async () =\u003e {\n    const events: any[] = []\n    cache.on('changed', (file, content, metadata) =\u003e {\n      events.push({ file, content, metadata })\n    })\n    \n    const newFile = await vault.create('new.md', '# New\\n[[link]]')\n    \n    // Wait for indexing\n    await new Promise(r =\u003e setTimeout(r, 10))\n    \n    expect(events).toHaveLength(1)\n    expect(events[0].metadata.links).toHaveLength(1)\n  })\n  \n  it('should emit resolve event when links are resolved', async () =\u003e {})\n  \n  it('should emit resolved event after all files indexed', async () =\u003e {\n    const events: string[] = []\n    cache.on('resolved', () =\u003e events.push('resolved'))\n    \n    await cache.initialize()\n    \n    expect(events).toContain('resolved')\n  })\n  \n  it('should re-index on vault modify event', async () =\u003e {})\n  it('should update link graph on vault rename', async () =\u003e {})\n  it('should clean up on vault delete', async () =\u003e {})\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:45.687831-06:00","updated_at":"2026-01-05T10:35:10.121972-06:00","closed_at":"2026-01-05T10:35:10.121972-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-mwk","title":"Epic: CLI Module - Command Line Interface","description":"\n# CLI Module\n\nCommand-line interface for obsidian.do operations.\n\n## Commands\n- search - Search notes\n- read/cat - Read note content\n- create - Create new note\n- edit - Edit note in $EDITOR\n- backlinks - Show backlinks\n- graph - Graph operations\n- serve - HTTP server mode\n- mcp - MCP server mode (stdio)\n\n## Features\n- Multiple output formats (text, json, markdown)\n- Configurable vault path\n- Watch mode for file changes\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-05T09:48:39.355074-06:00","updated_at":"2026-01-05T09:48:39.355074-06:00"}
{"id":"obsidian-oxs","title":"Epic: Search Module - Vault Search","description":"\n# Search Module\n\nSearch functionality for finding notes by content, tags, properties, and relationships.\n\n## Components\n- SearchEngine (main interface)\n- FuzzySearch (Obsidian-compatible fuzzy matching)\n- SimpleSearch (word-based matching)\n- StructuredSearch (tags, properties, links)\n\n## Key Features\n- Fuzzy and simple text search\n- Tag and property filtering\n- Content highlighting\n- Relevance scoring\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-05T09:41:27.745678-06:00","updated_at":"2026-01-05T09:41:27.745678-06:00"}
{"id":"obsidian-p0t","title":"CRITICAL: Fix bin entry point in package.json","description":"package.json bin points to dist/cli/index.js which only exports functions. Should point to dist/cli.js which actually executes main(). CLI doesn't work when installed globally.","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-05T13:20:09.960314-06:00","updated_at":"2026-01-05T13:38:12.087982-06:00","closed_at":"2026-01-05T13:38:12.087982-06:00","close_reason":"Fixed - CLI entry point now calls main() conditionally when run directly"}
{"id":"obsidian-ph0","title":"RED: MetadataCache - Link resolver tests","description":"\n# RED Phase: Link Resolver Tests\n\n```typescript\n// test/metadata/link-resolver.test.ts\ndescribe('Link resolution', () =\u003e {\n  it('should resolve exact path match', () =\u003e {\n    const target = cache.getFirstLinkpathDest('notes/b.md', 'notes/a.md')\n    expect(target?.path).toBe('notes/b.md')\n  })\n  \n  it('should resolve basename match', () =\u003e {\n    // [[b]] should resolve to notes/b.md\n    const target = cache.getFirstLinkpathDest('b', 'notes/a.md')\n    expect(target?.path).toBe('notes/b.md')\n  })\n  \n  it('should resolve with .md extension added', () =\u003e {\n    const target = cache.getFirstLinkpathDest('b.md', 'notes/a.md')\n    expect(target?.path).toBe('notes/b.md')\n  })\n  \n  it('should prefer same-folder match for ambiguous links', () =\u003e {\n    // If b.md exists in multiple folders, prefer the one in same folder as source\n  })\n  \n  it('should return null for unresolvable link', () =\u003e {\n    const target = cache.getFirstLinkpathDest('nonexistent', 'notes/a.md')\n    expect(target).toBeNull()\n  })\n  \n  it('should handle heading references', () =\u003e {\n    const target = cache.getFirstLinkpathDest('b#heading', 'notes/a.md')\n    expect(target?.path).toBe('notes/b.md')\n  })\n  \n  it('should handle block references', () =\u003e {\n    const target = cache.getFirstLinkpathDest('b#^block-id', 'notes/a.md')\n    expect(target?.path).toBe('notes/b.md')\n  })\n})\n\ndescribe('fileToLinktext', () =\u003e {\n  it('should generate shortest unambiguous link', () =\u003e {\n    const file = vault.getFileByPath('notes/b.md')!\n    const linktext = cache.fileToLinktext(file, 'notes/a.md')\n    expect(linktext).toBe('b')\n  })\n  \n  it('should include folder for disambiguation', () =\u003e {})\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:31.970911-06:00","updated_at":"2026-01-05T10:08:50.099956-06:00","closed_at":"2026-01-05T10:08:50.099956-06:00","close_reason":"RED phase tests written and verified failing"}
{"id":"obsidian-pin","title":"GREEN: Add missing JSDoc to public APIs","description":"ObsidianClient, Vault, SearchEngine public methods lack JSDoc. Add documentation for: getNote, createNote, updateNote, read, create, modify, search, findByTag, etc.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T13:22:37.117146-06:00","updated_at":"2026-01-05T13:38:50.780164-06:00","closed_at":"2026-01-05T13:38:50.780164-06:00","close_reason":"Fixed - JSDoc comments added to ObsidianClient, Vault, SearchEngine public APIs"}
{"id":"obsidian-pv7","title":"GREEN: Fix content cache invalidation in Vault.append()","description":"vault.ts append() method doesn't invalidate contentCache like modify() does. Causes stale reads after append operations.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-05T12:55:21.184206-06:00","updated_at":"2026-01-05T13:06:04.713613-06:00","closed_at":"2026-01-05T13:06:04.713613-06:00","close_reason":"Fixed, all tests pass"}
{"id":"obsidian-pws","title":"RED: MetadataCache - Core cache tests","description":"\n# RED Phase: MetadataCache Core Tests\n\n```typescript\n// test/metadata/cache.test.ts\ndescribe('MetadataCache', () =\u003e {\n  let vault: Vault\n  let cache: MetadataCache\n  \n  beforeEach(async () =\u003e {\n    vault = createTestVault({\n      'notes/a.md': '# A\\nLink to [[b]] and [[c]]',\n      'notes/b.md': '# B\\nLink to [[a]]',\n      'notes/c.md': '# C\\n#tag1 #tag2'\n    })\n    cache = new MetadataCache(vault)\n    await cache.initialize()\n  })\n  \n  describe('getFileCache', () =\u003e {\n    it('should return cached metadata for file', () =\u003e {\n      const file = vault.getFileByPath('notes/a.md')!\n      const metadata = cache.getFileCache(file)\n      \n      expect(metadata?.links).toHaveLength(2)\n      expect(metadata?.headings).toHaveLength(1)\n    })\n    \n    it('should return null for uncached file', () =\u003e {})\n  })\n  \n  describe('getCache', () =\u003e {\n    it('should return metadata by path string', () =\u003e {})\n  })\n  \n  describe('resolvedLinks', () =\u003e {\n    it('should track link counts between files', () =\u003e {\n      expect(cache.resolvedLinks['notes/a.md']['notes/b.md']).toBe(1)\n      expect(cache.resolvedLinks['notes/a.md']['notes/c.md']).toBe(1)\n    })\n  })\n  \n  describe('unresolvedLinks', () =\u003e {\n    it('should track links to non-existent files', async () =\u003e {\n      await vault.create('broken.md', 'Link to [[missing]]')\n      await cache.indexFile(vault.getFileByPath('broken.md')!)\n      \n      expect(cache.unresolvedLinks['broken.md']['missing']).toBe(1)\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:18.169276-06:00","updated_at":"2026-01-05T10:36:05.737031-06:00","closed_at":"2026-01-05T10:36:05.737031-06:00","close_reason":"TDD tests written (test files exist)","dependencies":[{"issue_id":"obsidian-pws","depends_on_id":"obsidian-byw","type":"blocks","created_at":"2026-01-05T09:48:35.090595-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-q3q","title":"GREEN: Fix README inaccuracies","description":"1. test:run described as 'watch mode' but runs once. 2. Graph API example shows wrong return type for getBacklinks(). 3. Missing serve command docs. 4. Missing CLI options (--limit, --folder, --port, --host).","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-05T13:21:55.209869-06:00","updated_at":"2026-01-05T13:38:37.577853-06:00","closed_at":"2026-01-05T13:38:37.577853-06:00","close_reason":"Fixed - README test script descriptions corrected"}
{"id":"obsidian-qu1","title":"RED: Search - Fuzzy search tests","description":"\n# RED Phase: Fuzzy Search Tests\n\n```typescript\n// test/search/fuzzy.test.ts\ndescribe('prepareFuzzySearch', () =\u003e {\n  it('should match exact substring', () =\u003e {\n    const search = prepareFuzzySearch('test')\n    const result = search('This is a test string')\n    \n    expect(result).not.toBeNull()\n    expect(result?.score).toBeGreaterThan(0)\n  })\n  \n  it('should match fuzzy patterns', () =\u003e {\n    const search = prepareFuzzySearch('tst')\n    const result = search('test')\n    \n    expect(result).not.toBeNull()\n  })\n  \n  it('should return higher score for better matches', () =\u003e {\n    const search = prepareFuzzySearch('test')\n    const exact = search('test')\n    const partial = search('testing something')\n    \n    expect(exact!.score).toBeGreaterThan(partial!.score)\n  })\n  \n  it('should return null for non-matches', () =\u003e {\n    const search = prepareFuzzySearch('xyz')\n    const result = search('abc')\n    \n    expect(result).toBeNull()\n  })\n  \n  it('should include match positions', () =\u003e {\n    const search = prepareFuzzySearch('test')\n    const result = search('This is a test string')\n    \n    expect(result?.matches).toBeDefined()\n    expect(result?.matches[0]).toEqual([10, 4]) // offset, length\n  })\n  \n  it('should be case insensitive', () =\u003e {\n    const search = prepareFuzzySearch('TEST')\n    const result = search('test')\n    \n    expect(result).not.toBeNull()\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:34.97555-06:00","updated_at":"2026-01-05T10:08:50.100406-06:00","closed_at":"2026-01-05T10:08:50.100406-06:00","close_reason":"RED phase tests written and verified failing"}
{"id":"obsidian-s0i","title":"GREEN: MetadataCache - Core cache implementation","description":"\n# GREEN Phase: MetadataCache Core\n\n```typescript\n// src/metadata/cache.ts\nexport class MetadataCache extends Events {\n  private cache = new Map\u003cstring, CachedMetadata\u003e()\n  resolvedLinks: Record\u003cstring, Record\u003cstring, number\u003e\u003e = {}\n  unresolvedLinks: Record\u003cstring, Record\u003cstring, number\u003e\u003e = {}\n  \n  constructor(\n    private vault: Vault,\n    private parser: typeof parseMarkdown = parseMarkdown\n  ) {\n    super()\n    this.setupVaultListeners()\n  }\n  \n  async initialize(): Promise\u003cvoid\u003e {\n    const files = this.vault.getMarkdownFiles()\n    for (const file of files) {\n      await this.indexFile(file)\n    }\n    this.trigger('resolved')\n  }\n  \n  getFileCache(file: TFile): CachedMetadata | null {\n    return this.cache.get(file.path) ?? null\n  }\n  \n  getCache(path: string): CachedMetadata | null {\n    return this.cache.get(path) ?? null\n  }\n  \n  async indexFile(file: TFile): Promise\u003cvoid\u003e {\n    const content = await this.vault.read(file)\n    const metadata = this.parser(content)\n    \n    this.cache.set(file.path, metadata)\n    this.updateLinkGraphs(file.path, metadata)\n    this.trigger('changed', file, content, metadata)\n  }\n  \n  private updateLinkGraphs(path: string, metadata: CachedMetadata): void {\n    // Clear old links\n    delete this.resolvedLinks[path]\n    delete this.unresolvedLinks[path]\n    \n    if (\\!metadata.links) return\n    \n    this.resolvedLinks[path] = {}\n    this.unresolvedLinks[path] = {}\n    \n    for (const link of metadata.links) {\n      const target = this.resolveLink(link.link, path)\n      if (target) {\n        this.resolvedLinks[path][target.path] = \n          (this.resolvedLinks[path][target.path] ?? 0) + 1\n      } else {\n        this.unresolvedLinks[path][link.link] = \n          (this.unresolvedLinks[path][link.link] ?? 0) + 1\n      }\n    }\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:24.641635-06:00","updated_at":"2026-01-05T11:26:24.687981-06:00","closed_at":"2026-01-05T11:26:24.687981-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-s0i","depends_on_id":"obsidian-pws","type":"blocks","created_at":"2026-01-05T09:48:03.652497-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-t1m","title":"GREEN: MCP - Tool definitions","description":"\n# GREEN Phase: MCP Tool Definitions\n\n```typescript\n// src/mcp/tools.ts\nexport interface Tool {\n  name: string\n  description: string\n  inputSchema: JsonSchema\n  annotations?: {\n    readOnlyHint?: boolean\n    destructiveHint?: boolean\n    idempotentHint?: boolean\n  }\n}\n\nexport const obsidianTools: Tool[] = [\n  {\n    name: 'vault_search',\n    description: 'Search notes in the vault by content, tags, or properties',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        query: { type: 'string', description: 'Search query' },\n        filter: {\n          type: 'object',\n          properties: {\n            folder: { type: 'string' },\n            tags: { type: 'array', items: { type: 'string' } }\n          }\n        },\n        limit: { type: 'number', default: 20 }\n      },\n      required: ['query']\n    },\n    annotations: { readOnlyHint: true }\n  },\n  {\n    name: 'note_read',\n    description: 'Read the content and metadata of a note',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string', description: 'Path to the note' },\n        includeBacklinks: { type: 'boolean', default: false }\n      },\n      required: ['path']\n    },\n    annotations: { readOnlyHint: true }\n  },\n  {\n    name: 'note_create',\n    description: 'Create a new note in the vault',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        content: { type: 'string' },\n        frontmatter: { type: 'object' }\n      },\n      required: ['path', 'content']\n    },\n    annotations: { destructiveHint: true }\n  },\n  // ... other tools\n]\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:29.440017-06:00","updated_at":"2026-01-05T12:16:05.514263-06:00","closed_at":"2026-01-05T12:16:05.514263-06:00","close_reason":"Implementation complete, all tests pass"}
{"id":"obsidian-tc9","title":"RED: MCP - Tool definitions tests","description":"\n# RED Phase: MCP Tool Definitions Tests\n\n```typescript\n// test/mcp/tools.test.ts\ndescribe('Tool definitions', () =\u003e {\n  describe('obsidianTools', () =\u003e {\n    it('should define all required tools', () =\u003e {\n      const toolNames = obsidianTools.map(t =\u003e t.name)\n      \n      expect(toolNames).toContain('vault_search')\n      expect(toolNames).toContain('vault_list')\n      expect(toolNames).toContain('note_read')\n      expect(toolNames).toContain('note_create')\n      expect(toolNames).toContain('note_update')\n      expect(toolNames).toContain('note_append')\n      expect(toolNames).toContain('frontmatter_update')\n      expect(toolNames).toContain('graph_backlinks')\n      expect(toolNames).toContain('graph_forward_links')\n      expect(toolNames).toContain('graph_neighbors')\n      expect(toolNames).toContain('vault_context')\n    })\n    \n    it('should have valid input schemas', () =\u003e {\n      for (const tool of obsidianTools) {\n        expect(tool.inputSchema).toBeDefined()\n        expect(tool.inputSchema.type).toBe('object')\n      }\n    })\n    \n    it('should have descriptions', () =\u003e {\n      for (const tool of obsidianTools) {\n        expect(tool.description).toBeDefined()\n        expect(tool.description.length).toBeGreaterThan(10)\n      }\n    })\n    \n    it('should have appropriate annotations', () =\u003e {\n      const readTool = obsidianTools.find(t =\u003e t.name === 'note_read')\n      expect(readTool?.annotations?.readOnlyHint).toBe(true)\n      \n      const createTool = obsidianTools.find(t =\u003e t.name === 'note_create')\n      expect(createTool?.annotations?.destructiveHint).toBe(true)\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:22.833107-06:00","updated_at":"2026-01-05T10:33:52.179034-06:00","closed_at":"2026-01-05T10:33:52.179034-06:00","close_reason":"TDD tests written and verified failing"}
{"id":"obsidian-tj5","title":"REFACTOR: Remove duplicate CLI implementations","description":"cli/index.ts has duplicate command implementations in main() and createCli(). Remove main() manual arg parsing, keep cac-based createCli().","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T12:55:54.402041-06:00","updated_at":"2026-01-05T13:11:58.140188-06:00","closed_at":"2026-01-05T13:11:58.140188-06:00","close_reason":"Refactoring complete, all tests pass"}
{"id":"obsidian-tkg","title":"GREEN: Graph - Analysis implementation","description":"\n# GREEN Phase: Graph Analysis\n\n```typescript\n// src/graph/analysis.ts\nexport function getOrphans(graph: GraphEngine): TFile[] {\n  const files = graph.vault.getMarkdownFiles()\n  \n  return files.filter(file =\u003e {\n    const hasOutgoing = graph.getForwardLinks(file.path).length \u003e 0\n    const hasIncoming = graph.getBacklinks(file.path).length \u003e 0\n    return !hasOutgoing \u0026\u0026 !hasIncoming\n  })\n}\n\nexport function getDeadLinks(graph: GraphEngine): UnresolvedLink[] {\n  const results: UnresolvedLink[] = []\n  \n  for (const [sourcePath, targets] of Object.entries(graph.metadataCache.unresolvedLinks)) {\n    for (const [link, count] of Object.entries(targets)) {\n      results.push({\n        source: sourcePath,\n        link,\n        count\n      })\n    }\n  }\n  \n  return results\n}\n\nexport function getMostLinked(graph: GraphEngine, limit?: number): { file: TFile; count: number }[] {\n  const linkCounts = new Map\u003cstring, number\u003e()\n  \n  for (const targets of Object.values(graph.metadataCache.resolvedLinks)) {\n    for (const [target, count] of Object.entries(targets)) {\n      linkCounts.set(target, (linkCounts.get(target) ?? 0) + count)\n    }\n  }\n  \n  return Array.from(linkCounts.entries())\n    .map(([path, count]) =\u003e ({ file: graph.vault.getFileByPath(path)!, count }))\n    .filter(r =\u003e r.file)\n    .sort((a, b) =\u003e b.count - a.count)\n    .slice(0, limit)\n}\n\nexport function getClusters(graph: GraphEngine): TFile[][] {\n  // Union-Find for connected components\n  const files = graph.vault.getMarkdownFiles()\n  const parent = new Map\u003cstring, string\u003e()\n  \n  // Initialize each file as its own parent\n  files.forEach(f =\u003e parent.set(f.path, f.path))\n  \n  function find(x: string): string {\n    if (parent.get(x) !== x) {\n      parent.set(x, find(parent.get(x)!))\n    }\n    return parent.get(x)!\n  }\n  \n  function union(x: string, y: string): void {\n    parent.set(find(x), find(y))\n  }\n  \n  // Union connected nodes\n  for (const [source, targets] of Object.entries(graph.metadataCache.resolvedLinks)) {\n    for (const target of Object.keys(targets)) {\n      union(source, target)\n    }\n  }\n  \n  // Group by root\n  const clusters = new Map\u003cstring, TFile[]\u003e()\n  files.forEach(f =\u003e {\n    const root = find(f.path)\n    if (!clusters.has(root)) clusters.set(root, [])\n    clusters.get(root)!.push(f)\n  })\n  \n  return Array.from(clusters.values())\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:42:02.106778-06:00","updated_at":"2026-01-05T10:42:28.670207-06:00","closed_at":"2026-01-05T10:42:28.670207-06:00","close_reason":"Implementation completed, tests pass","dependencies":[{"issue_id":"obsidian-tkg","depends_on_id":"obsidian-ezh","type":"blocks","created_at":"2026-01-05T09:48:53.111762-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-tq5","title":"Epic: Graph Module - Knowledge Graph Operations","description":"\n# Graph Module\n\nKnowledge graph operations for traversing and analyzing vault connections.\n\n## Components\n- GraphEngine (main interface)\n- Traversal algorithms (BFS, DFS, shortest path)\n- Analysis (orphans, clusters, density)\n\n## Key Operations\n- getBacklinks / getForwardLinks\n- getNeighbors (n-hop exploration)\n- findPath (shortest path between notes)\n- getOrphans / getDeadLinks\n- getClusters (connected components)\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-05T09:41:20.623727-06:00","updated_at":"2026-01-05T09:41:20.623727-06:00"}
{"id":"obsidian-tym","title":"RED: Vault - FileManager tests","description":"\n# RED Phase: FileManager Tests\n\n```typescript\n// test/vault/file-manager.test.ts\ndescribe('FileManager', () =\u003e {\n  it('should rename file and update all links', async () =\u003e {\n    // Create files with links\n    await vault.create('source.md', 'Link to [[target]]')\n    await vault.create('target.md', '# Target')\n    \n    await fileManager.renameFile(\n      vault.getFileByPath('target.md')\\!,\n      'new-target.md'\n    )\n    \n    const sourceContent = await vault.read(vault.getFileByPath('source.md')\\!)\n    expect(sourceContent).toBe('Link to [[new-target]]')\n  })\n  \n  it('should generate markdown link with relative path', () =\u003e {\n    const link = fileManager.generateMarkdownLink(\n      vault.getFileByPath('notes/target.md')\\!,\n      'notes/source.md'\n    )\n    expect(link).toBe('[[target]]')\n  })\n  \n  it('should generate markdown link with alias', () =\u003e {\n    const link = fileManager.generateMarkdownLink(\n      vault.getFileByPath('target.md')\\!,\n      'source.md',\n      undefined,\n      'Click here'\n    )\n    expect(link).toBe('[[target|Click here]]')\n  })\n  \n  it('should process frontmatter atomically', async () =\u003e {})\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:36.32811-06:00","updated_at":"2026-01-05T10:35:10.122409-06:00","closed_at":"2026-01-05T10:35:10.122409-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-v3f","title":"GREEN: Graph - Backlinks implementation","description":"\n# GREEN Phase: Graph Backlinks\n\n```typescript\n// src/graph/engine.ts\nexport interface BacklinkResult {\n  file: TFile\n  links: LinkCache[]\n  context: string[]\n}\n\nexport class GraphEngine {\n  constructor(private metadataCache: MetadataCache) {}\n  \n  getBacklinks(path: string): BacklinkResult[] {\n    const results: BacklinkResult[] = []\n    const { resolvedLinks } = this.metadataCache\n    \n    for (const [sourcePath, targets] of Object.entries(resolvedLinks)) {\n      if (targets[path]) {\n        const sourceFile = this.metadataCache.vault.getFileByPath(sourcePath)\n        const metadata = this.metadataCache.getCache(sourcePath)\n        \n        if (sourceFile \u0026\u0026 metadata?.links) {\n          const relevantLinks = metadata.links.filter(\n            l =\u003e this.metadataCache.getFirstLinkpathDest(l.link, sourcePath)?.path === path\n          )\n          \n          results.push({\n            file: sourceFile,\n            links: relevantLinks,\n            context: relevantLinks.map(l =\u003e this.getContext(sourcePath, l.position))\n          })\n        }\n      }\n    }\n    \n    return results\n  }\n  \n  getForwardLinks(path: string): LinkCache[] {\n    const metadata = this.metadataCache.getCache(path)\n    return metadata?.links ?? []\n  }\n  \n  private getContext(path: string, position: Pos): string {\n    // Extract surrounding text for context\n  }\n}\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:35.570133-06:00","updated_at":"2026-01-05T11:33:10.234192-06:00","closed_at":"2026-01-05T11:33:10.234192-06:00","close_reason":"Implementation complete, all tests pass","dependencies":[{"issue_id":"obsidian-v3f","depends_on_id":"obsidian-lxq","type":"blocks","created_at":"2026-01-05T09:48:42.223129-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-vf9","title":"CRITICAL: Filesystem backend fails to scan files","description":"ObsidianClient.initialize() doesn't scan filesystem backend. Vault.getMarkdownFiles() returns empty array. Only memory backend works.","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-05T13:24:26.760596-06:00","updated_at":"2026-01-05T13:39:33.038321-06:00","closed_at":"2026-01-05T13:39:33.038321-06:00","close_reason":"Fixed - FileSystemBackend now has initialize() that scans vault directory and populates files map"}
{"id":"obsidian-vzg","title":"[obsidian] Publish package to npm","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T12:09:51.583047-06:00","updated_at":"2026-01-05T12:31:31.70751-06:00","closed_at":"2026-01-05T12:31:31.70751-06:00","close_reason":"Package prepared for npm publishing. Dry-run successful (129.1 kB, 95 files). Manual npm login required for actual publish."}
{"id":"obsidian-wxy","title":"RED: MCP - Server tests","description":"\n# RED Phase: MCP Server Tests\n\n```typescript\n// test/mcp/server.test.ts\ndescribe('MCP Server', () =\u003e {\n  let server: ObsidianMcpServer\n  let client: ObsidianClient\n  \n  beforeEach(async () =\u003e {\n    client = new ObsidianClient({\n      backend: 'memory',\n      initialFiles: {\n        'test.md': '# Test\\n[[link]] #tag',\n        'other.md': '# Other\\nContent here'\n      }\n    })\n    await client.initialize()\n    server = createMcpServer({ client })\n  })\n  \n  describe('initialize', () =\u003e {\n    it('should respond to initialize request', async () =\u003e {\n      const response = await server.handleRequest({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'initialize',\n        params: {\n          protocolVersion: '2024-11-05',\n          clientInfo: { name: 'test', version: '1.0' },\n          capabilities: {}\n        }\n      })\n      \n      expect(response.result.serverInfo.name).toBe('obsidian.do')\n      expect(response.result.capabilities.tools).toBeDefined()\n    })\n  })\n  \n  describe('tools/list', () =\u003e {\n    it('should list all available tools', async () =\u003e {\n      const response = await server.handleRequest({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/list',\n        params: {}\n      })\n      \n      const tools = response.result.tools\n      expect(tools.map(t =\u003e t.name)).toContain('vault_search')\n      expect(tools.map(t =\u003e t.name)).toContain('note_read')\n      expect(tools.map(t =\u003e t.name)).toContain('note_create')\n      expect(tools.map(t =\u003e t.name)).toContain('graph_backlinks')\n    })\n    \n    it('should include input schemas', () =\u003e {\n      // Each tool should have inputSchema\n    })\n  })\n  \n  describe('tools/call', () =\u003e {\n    it('should call vault_search tool', async () =\u003e {\n      const response = await server.handleRequest({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/call',\n        params: {\n          name: 'vault_search',\n          arguments: { query: 'test' }\n        }\n      })\n      \n      expect(response.result.content).toBeDefined()\n      expect(response.result.content[0].type).toBe('text')\n    })\n    \n    it('should call note_read tool', async () =\u003e {\n      const response = await server.handleRequest({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/call',\n        params: {\n          name: 'note_read',\n          arguments: { path: 'test.md' }\n        }\n      })\n      \n      expect(response.result.content[0].text).toContain('# Test')\n    })\n    \n    it('should return error for invalid tool', async () =\u003e {\n      const response = await server.handleRequest({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/call',\n        params: {\n          name: 'invalid_tool',\n          arguments: {}\n        }\n      })\n      \n      expect(response.error).toBeDefined()\n    })\n    \n    it('should validate input schema', async () =\u003e {\n      const response = await server.handleRequest({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'tools/call',\n        params: {\n          name: 'note_read',\n          arguments: {} // Missing required 'path'\n        }\n      })\n      \n      expect(response.error).toBeDefined()\n    })\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:48:51.318502-06:00","updated_at":"2026-01-05T10:35:10.117623-06:00","closed_at":"2026-01-05T10:35:10.117623-06:00","close_reason":"TDD tests written"}
{"id":"obsidian-x49","title":"RED: Vault - File discovery tests","description":"\n# RED Phase: Vault Discovery Tests\n\n```typescript\ndescribe('Vault discovery', () =\u003e {\n  it('should get file by path', () =\u003e {\n    const file = vault.getFileByPath('notes/test.md')\n    expect(file).toBeDefined()\n    expect(file?.path).toBe('notes/test.md')\n  })\n  \n  it('should return null for non-existent path', () =\u003e {\n    expect(vault.getFileByPath('missing.md')).toBeNull()\n  })\n  \n  it('should get abstract file by path (file or folder)', () =\u003e {})\n  \n  it('should get all markdown files', () =\u003e {\n    const files = vault.getMarkdownFiles()\n    expect(files.every(f =\u003e f.extension === 'md')).toBe(true)\n  })\n  \n  it('should get all files', () =\u003e {})\n  it('should get all loaded files', () =\u003e {})\n  it('should get all folders', () =\u003e {})\n  it('should include/exclude root folder', () =\u003e {})\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:41:11.063175-06:00","updated_at":"2026-01-05T10:08:50.098909-06:00","closed_at":"2026-01-05T10:08:50.098909-06:00","close_reason":"RED phase tests written and verified failing"}
{"id":"obsidian-x67","title":"RED: Search - Engine integration tests","description":"\n# RED Phase: Search Engine Tests\n\n```typescript\n// test/search/engine.test.ts\ndescribe('SearchEngine', () =\u003e {\n  let vault: Vault\n  let cache: MetadataCache\n  let search: SearchEngine\n  \n  beforeEach(async () =\u003e {\n    vault = createTestVault({\n      'projects/alpha.md': '# Alpha Project\\n#project #active\\nBuilding something cool',\n      'projects/beta.md': '# Beta Project\\n#project #archived\\nOld project',\n      'notes/meeting.md': '# Meeting Notes\\nDiscussed Alpha Project progress',\n      'daily/2024-01-01.md': '# Daily Note\\n#daily\\nWorked on Alpha'\n    })\n    cache = new MetadataCache(vault)\n    await cache.initialize()\n    search = new SearchEngine(vault, cache)\n  })\n  \n  describe('search', () =\u003e {\n    it('should search file content', async () =\u003e {\n      const results = await search.search('Alpha')\n      \n      expect(results).toHaveLength(3)  // alpha.md, meeting.md, daily\n    })\n    \n    it('should sort by relevance score', async () =\u003e {\n      const results = await search.search('Alpha Project')\n      \n      expect(results[0].file.path).toBe('projects/alpha.md')\n    })\n    \n    it('should respect limit option', async () =\u003e {\n      const results = await search.search('project', { limit: 2 })\n      \n      expect(results).toHaveLength(2)\n    })\n    \n    it('should filter by folder', async () =\u003e {\n      const results = await search.search('project', {\n        filter: { folder: 'projects' }\n      })\n      \n      expect(results.every(r =\u003e r.file.path.startsWith('projects/'))).toBe(true)\n    })\n    \n    it('should filter by tags', async () =\u003e {\n      const results = await search.search('', {\n        filter: { tags: ['active'] }\n      })\n      \n      expect(results).toHaveLength(1)\n      expect(results[0].file.path).toBe('projects/alpha.md')\n    })\n  })\n  \n  describe('findByTag', () =\u003e {\n    it('should find all files with tag', () =\u003e {\n      const files = search.findByTag('project')\n      \n      expect(files).toHaveLength(2)\n    })\n    \n    it('should match nested tags', () =\u003e {\n      // #parent/child should match search for #parent\n    })\n  })\n  \n  describe('findByProperty', () =\u003e {\n    it('should find files by frontmatter property', () =\u003e {})\n  })\n  \n  describe('findByLink', () =\u003e {\n    it('should find files linking to target', () =\u003e {})\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:42:01.070515-06:00","updated_at":"2026-01-05T10:33:34.484219-06:00","closed_at":"2026-01-05T10:33:34.484219-06:00","close_reason":"TDD tests written and verified failing","dependencies":[{"issue_id":"obsidian-x67","depends_on_id":"obsidian-s0i","type":"blocks","created_at":"2026-01-05T09:49:52.86614-06:00","created_by":"nathanclevenger"}]}
{"id":"obsidian-xl2","title":"GREEN: Export missing public types","description":"index.ts missing exports: SearchResult, SearchOptions, VaultStats, GraphStats, DeadLink, LinkedFile, NodeDegree from graph.ts and search/engine.ts. Users need these types.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T13:22:55.153913-06:00","updated_at":"2026-01-05T13:38:57.089588-06:00","closed_at":"2026-01-05T13:38:57.089588-06:00","close_reason":"Fixed - SearchResult, SearchOptions, VaultStats, GraphStats now exported from index.ts"}
{"id":"obsidian-y2t","title":"RED: CLI - MCP command tests","description":"\n# RED Phase: CLI MCP Command Tests\n\n```typescript\n// test/cli/mcp.test.ts\ndescribe('mcp command', () =\u003e {\n  it('should start MCP server on stdio', async () =\u003e {\n    const proc = spawn('node', [cliPath, 'mcp', '--vault', tempDir])\n    \n    // Send initialize request\n    const initRequest = JSON.stringify({\n      jsonrpc: '2.0',\n      id: 1,\n      method: 'initialize',\n      params: {\n        protocolVersion: '2024-11-05',\n        clientInfo: { name: 'test', version: '1.0' },\n        capabilities: {}\n      }\n    })\n    \n    proc.stdin.write(initRequest + '\\n')\n    \n    const response = await readStdout(proc)\n    const parsed = JSON.parse(response)\n    \n    expect(parsed.result.serverInfo.name).toBe('obsidian.do')\n    \n    proc.kill()\n  })\n  \n  it('should respond to tools/list', async () =\u003e {\n    // Similar test for tools/list\n  })\n  \n  it('should handle tools/call', async () =\u003e {\n    // Test tool invocation via stdio\n  })\n})\n```\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T09:49:45.915743-06:00","updated_at":"2026-01-05T10:33:52.178081-06:00","closed_at":"2026-01-05T10:33:52.178081-06:00","close_reason":"TDD tests written and verified failing"}
{"id":"obsidian-z8k","title":"Epic: MetadataCache Module - Metadata Indexing","description":"\n# MetadataCache Module\n\nIndexes and caches metadata extracted from markdown files. Maintains link graph for backlinks and forward links.\n\n## Components\n- MetadataCache class (main interface)\n- Indexer (parses files on change)\n- LinkResolver (resolves link targets)\n\n## Key Features\n- resolvedLinks / unresolvedLinks graphs\n- Event emission on cache updates\n- Link resolution with path ambiguity handling\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-05T09:41:11.680052-06:00","updated_at":"2026-01-05T09:41:11.680052-06:00"}
{"id":"obsidian-zsp","title":"REFACTOR: Search module - indexing and performance","description":"\n# REFACTOR Phase: Search Module\n\n## Tasks\n- [ ] Implement inverted index for faster search\n- [ ] Add search result highlighting helpers\n- [ ] Implement search history / recent searches\n- [ ] Add search suggestions\n- [ ] Optimize for large vaults (streaming)\n- [ ] Add semantic search placeholder\n- [ ] Comprehensive JSDoc\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Sub-100ms search for 10k notes\n- [ ] Memory-efficient indexing\n","status":"in_progress","priority":3,"issue_type":"task","created_at":"2026-01-05T09:42:14.161868-06:00","updated_at":"2026-01-05T14:01:12.299048-06:00","dependencies":[{"issue_id":"obsidian-zsp","depends_on_id":"obsidian-lrj","type":"blocks","created_at":"2026-01-05T09:49:37.100667-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-zsp","depends_on_id":"obsidian-ei6","type":"blocks","created_at":"2026-01-05T09:49:42.358583-06:00","created_by":"nathanclevenger"},{"issue_id":"obsidian-zsp","depends_on_id":"obsidian-6fw","type":"blocks","created_at":"2026-01-05T09:49:47.614748-06:00","created_by":"nathanclevenger"}]}
